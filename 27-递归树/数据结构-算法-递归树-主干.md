# 递归树

[TOC]

## 递归树与时间复杂度分析

递归的思想：将大问题分解为小问题来求解，然后再将小问题分解为小小问题。这样一层一层地分解，直到问题的数据规模被分解得足够小，不用继续递归分解为止。

如果我们把这个一层一层的分解过程画成图，它其实就是一棵树。我们给这棵树起一个名字，叫作递归树。节点里的数字表示数据的规模，一个节点的求解可以分解为左右子节点两个问题的求解。

![1553523647626](D:\Documents\笔记本\offer学习复习\递归树\1553523647626.png)

## 归并排序递归树

![1553523721918](D:\Documents\笔记本\offer学习复习\递归树\1553523721918.png)

可以看出，每一层归并操作消耗的时间总和是一样的，跟要排序的数据规模有关。我们把每一层归并操作消耗的时间记作 n。

现在，只需要知道这棵树的高度h，用高度 h乘以每一层的时间消耗n，就可以得到总的时间复杂度O（n*h）。

归并排序递归树是一棵满二叉树。满二叉树的高度大约是log2n，所以，归并排序递归实现的时间复杂度就是O（nlogn）。

## 实战一：分析快速排序的时间复杂度

![1553523979891](D:\Documents\笔记本\offer学习复习\递归树\1553523979891.png)

每一层分区操作所遍历的数据的个数之和就是n。我们现在只要求出递归树的高度h，这个快排过程遍历的数据个数就是h*n，也就是说，时间复杂度就是O（h\*n）。

![1553524088506](D:\Documents\笔记本\offer学习复习\递归树\1553524088506.png)

也就是说，对于k等于 9，99，甚至是999，9999..…，只要 k 的值不随 n变化，是一个事先确定的常量，那快排的时间复杂度就是O（nlogn）。所以，从概率论的角度来说，快排的平均时间复杂度就是O（nlogn）。

## 实战二：分析斐波那契数列的时间复杂度

![1553524287213](D:\Documents\笔记本\offer学习复习\递归树\1553524287213.png)

![1553524326653](D:\Documents\笔记本\offer学习复习\递归树\1553524326653.png)

时间复杂度：介于 O(2<sup>n</sup>) 和 O(2<sup>n/2</sup>)，指数级别，非常高。

实战三：分析全排列的时间复杂度

何为全排列？“如何把n个数据的所有排列都找出来”

如果我们确定了最后一位数据，那就变成了求解剩下n-1个数据的排列问题。而，最后一位数据可以是n个数据中的任意一个，因此它的取值就有n种情况。所以，“n个数据的排列”问题，就可以分解成n个“n-1个数据的排列”的子问题。

```
假设数组中存储的是 1，2， 3...n。
        
f(1,2,...n) = {最后一位是 1, f(n-1)} + {最后一位是 2, f(n-1)} +...+{最后一位是 n, f(n-1)}。

// code
// 调用方式：
// int[]a = a={1, 2, 3, 4}; printPermutations(a, 4, 4);
// k 表示要处理的子数组的数据个数
public void printPermutations(int[] data, int n, int k) {
  if (k == 1) {
    for (int i = 0; i < n; ++i) {
      System.out.print(data[i] + " ");
    }
    System.out.println();
  }

  for (int i = 0; i < k; ++i) {
    int tmp = data[i];
    data[i] = data[k-1];
    data[k-1] = tmp;

    printPermutations(data, n, k - 1);

    tmp = data[i];
    data[i] = data[k-1];
    data[k-1] = tmp;
  }
}
```

![1553524711968](D:\Documents\笔记本\offer学习复习\递归树\1553524711968.png)

```
第 k 层总的交换次数
n + n*(n-1) + n*(n-1)*(n-2) +... + n*(n-1)*(n-2)*...*2*1
```

## 场景

1个细胞的生命周期是3小时，1小时分裂一次。求n小时后，容器内有多少细胞？请你用已经学过的递归时间复杂度的分析方法，分析一下这个递归问题的时间复杂度。

其一

假设细胞到了第三个小时是先分裂完再死亡，那么递推公式就应该是：
f(n) = f(n-1)*2 - f(n-3)
一次乘法和一次减法一起看作一次基本操作消耗，那么情况和斐波那契数列很像。
最高的树应该有n层， 最短的是n/3层，每层操作数都是指数增长。
那么时间复杂度应该是在O(2^n)量级的。

其二

假设细胞先分裂再死亡，即，每个细胞分裂三次后死亡（存活三个小时）。

n 从第 0 个小时开始，

n = 0，f(0) = 1

n = 1，f(1) = 2*f(1)

n = 2，f(2) = 2*f(1)

n = 3，f(3) = 2*f(2) - f(0) ，减去存活了三个小时的细胞个数。

n = 4，f(4) = 2*f(3) - f(1)，减去存活了三个小时的细胞个数。

以此类推：

f(n) = 2*f(n-1) - f(n-3)，减去存活了三个小时的细胞个数。  