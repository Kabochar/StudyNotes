# BM 算法

[TOC]

基础

举例：主串中的 c，在模式串中是不存在的，所以，模式串向后滑动的时候，只要c与模式串有重合，肯定无法匹配。所以，我们可以一次性把模式串往后多滑动几位，把模式串移动到c的后面。

![1553650896873](D:\Documents\笔记本\offer学习复习\BF-RK-BM-字符串匹配\1553650896873.png)

借助这种规律，在模式串与主串匹配的过程中，当模式串和主串某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位。从而提高匹配效率。

BM算法原理分析

BM算法包含两部分，分别是坏字符规则（bad character rule）和好后缀规则（good sufix shift）。

1，坏字符串规则

匹配顺序不同，它按照模式串下标从大到小的顺序，倒着匹配。

![1553651049088](D:\Documents\笔记本\offer学习复习\BF-RK-BM-字符串匹配\1553651049088.png)

坏字符：我们从模式串的末尾往前倒着匹配，当我们发现某个字符没法匹配的时候。我们把这个没有匹配的字符叫作 坏字符（主串中的字符）。

坏字符c在模式串中查找，发现模式串中并不存在这个字符，也就是说，字符c与模式串中的任何字符都不可能匹配。这个时候，我们可以将模式串直接往后滑动三位，将模式串滑动到c后面的位置，再从模式串的未尾字符开始比较。

![1553651106722](D:\Documents\笔记本\offer学习复习\BF-RK-BM-字符串匹配\1553651106722.png)

模式串中最后一个字符d，还是无法跟主串中的a匹配，这个时候，还能将模式串往后滑动三位吗？答案是不行的。

因为这个时候，坏字符a在模式串中是存在的，模式串中下标是0的位置也是字符a。这种情况下，我们可以将模式串往后滑动两位，让两个a上下对齐，然后再从模式串的未尾字符开始，重新匹配。

![1553651160885](D:\Documents\笔记本\offer学习复习\BF-RK-BM-字符串匹配\1553651160885.png)

将模式串滑动，那具体滑动多少位，到底有没有规律呢？

xi & si 当发生不匹配的时候，我们把坏字符对应的模式串中的字符下标记作 si。如果坏字符在模式串中存在，我们把这个坏字符在模式串中的下标记作 xi。

如果不存在，我们把 xi 记作 -1。那模式串往后移动的位数就等于 si - xi。（注意，我这里说的下标，都是字符在模式串的下标）

![1553651284480](D:\Documents\笔记本\offer学习复习\BF-RK-BM-字符串匹配\1553651284480.png)

如果坏字符在模式串里多处出现，那我们在计算xi的时候，选择最靠后的那个，因为这样不会让模式串滑动过多，导致本来可能匹配的情况被滑动略过。

BM算法在最好情况下的时间复杂度非常低，是 O（n/m）。

单纯使用坏字符规则还是不够的，因为根据 si-xi 计算出来的移动位数，有可能是负数，比如主串是aaaaaaaaaaaaaaaa，模式串是baaa。

2，好后缀规则

![1553651382105](D:\Documents\笔记本\offer学习复习\BF-RK-BM-字符串匹配\1553651382105.png)

把已经匹配的 bc 叫作 好后缀，记作 {u}。我们拿它在模式串中查找，如果找到了另一个跟 {u} 相匹配的子串 {u*}，那我们就将模式串滑动到子串{u与主串中{u}对齐的位置。

![1553651424334](D:\Documents\笔记本\offer学习复习\BF-RK-BM-字符串匹配\1553651424334.png)

如果在模式串中找不到另一个等于{u}的子串，我们就直接将模式串，滑动到主串中{u}的后面，因为之前的任何一次往后滑动，都没有匹配主串中{u的情况。

![1553651452238](D:\Documents\笔记本\offer学习复习\BF-RK-BM-字符串匹配\1553651452238.png)

图这里面bc是好后缀，尽管在模式串中没有另外一个相匹配的子串{u，但是如果我们将模式串移动到好后缀的后面，那就会错过模式串和主串可以匹配的情况。

![1553651511504](D:\Documents\笔记本\offer学习复习\BF-RK-BM-字符串匹配\1553651511504.png)

如果好后缀在模式串中不存在可匹配的子串，那在我们一步一步往后滑动模式串的过程中，只要主串中的{u}与模式串有重合，那肯定就无法完全匹配。但是当模式串滑动到前缀与主串中{u}的后缀有部分重合的时候，并且重合的部分相等的时候，就有可能会存在完全匹配的情况。

针对这种情况，我们不仅要看好后缀在模式串中，是否有另一个匹配的子串，我们还要考察好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的。

某个字符串s的后缀子串，就是最后一个字符跟 s对齐的子串；前缀子串，就是起始字符跟 s对齐的子串，

从好后缀的后缀子串中，找一个最长的并且能跟模式串的前缀子串匹配的，假设是{v}，然后将模式串滑动到如图所示的位置。

![1553651689925](D:\Documents\笔记本\offer学习复习\BF-RK-BM-字符串匹配\1553651689925.png)

如何选择用好后缀规则还是坏字符规则，来计算模式串往后滑动的位数？

我们可以分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数。这种处理方法还可以避免我们前面提到的，根据坏字符规则，t 算得到的往后滑动的位数，有可能是负数的情况。

## 总结

BM算法核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，以此来减少不必要的字符比较，提高匹配的效率。

BM算法构建的规则有两类，坏字符规则和好后缀规则。好后缀规则可以独立于坏字符规则使用。因为坏字符规则的实现比较耗内存，为了节省内存，我们可以只用好后缀规则来实现BM算法。

@Smallfly

文章中值得学习借鉴的思想有：

1、要有优化意识，前面的 BF，RK 算法已经能够满足我们需求了，为什么发明 BM 算法？是为了减少时间复杂度，但是带来的弊端是，优化代码变得复杂，维护成本变高。

2、需要查找，需要减少时间复杂度，应该想到什么？散列表。

3、如果某个表达式计算开销比较大，又需要频繁的使用怎么办？预处理，并缓存。  