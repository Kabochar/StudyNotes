# 跳表

[TOC]

## 概念

跳表：在 链表的基础上 添加 多级索引的结构。

添加来一层索引之后，查找一个结点需要遍历的结点个数减少了，相对是 查找效率提高了。

![1553409262666](pics\1553409262666.png)

## 复杂度分析

### 时间复杂度

查询： O（logn）

插入，删除操作：O（logn）

每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n / 2，第二级索引的结点个数大约就是 n / 4，第三级索引的结点个数大约就是 n / 8，依次类推，第k级索引的结点个数是第 k-1 级索引的结点个数的 1 / 2，那第k级索引结点的个数就是 n /（2k）。

假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 n /（2h）=2，从而求得 h = log<sub>2</sub>n - 1。如果包含原始链表这一层，整个跳表的高度就是 log<sub>2</sub>n。我们在跳表中查询某个数据的时候，如果每一层都要遍历m个结点，那在跳表中查询一个数据的时间复杂度就是O（m*logn）。

那这个m的值是多少呢？按照前面这种索引结构，我们每一级索引都最多只需要遍历 3个结点。

在跳表中查询任意数据的时间复杂度就是 O（logn）。这个查找的时间复杂度跟二分查找是一样的。换句话说，其实是基于单链表实现了二分查找。不过查询效率的提升，前提是建立了很多级索引，也就是空间换时间的设计思路。

### 空间复杂度

每 2个结点一个索引：结点总和 n-2，总复杂度 O(n)

每 3个结点一个索引：结点总和 n/2，总复杂度 O(n)

实际上，在软件开发中，我们不必太在意索引占用的额外空间。在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。

## 动态插入 和 删除

插入，删除操作时间复杂度：O（logn）

插入操作

![1553410405279](pics\1553410405279.png)

删除操作

如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。

## 索引动态更新

跳表是通过 随机函数来维护“平衡性”。

当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢？通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第K级这K级索引中。

随机函数选择有讲究，不必深入探讨。可以查看 Redis 的实现代码

![1553410584429](pics\1553410584429.png)

## 场景

为什么Redis 要用跳表来实现有序集合，而不是红黑树？

Redis 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表。

1，插入、删除、查找 以及 迭代输出 有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。

2，Redis 之所以用跳表来实现有序集合，还有其他原因，比如，跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。

3，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的Map类型都是通过红黑树来实现的。

