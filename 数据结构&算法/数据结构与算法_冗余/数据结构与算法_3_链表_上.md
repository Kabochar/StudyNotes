# 链表 上

[TOC]

## 餐前点心：缓存的前世今生

### 1）什么是缓存？

缓存是一种提高数据读取性能的技术，在硬件设计，软件开发中都有着非常广泛的使用，比如常见的CPU 缓存，数据库缓存，浏览器缓存等等

### 2）为什么使用缓存？即缓存的特点

缓存的大小是有限的。

当缓存被用满时，哪些数据应该被清理出去？哪些数据应该被保留？

### 3）什么是缓存淘汰策略？

指的是 当缓存被用满时 清理缓存的优先顺序；

### 4）有哪些缓存淘汰策略？

常见的 3种 包括：

先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frenquently Used）、最近最少使用策略LRU（Least Recently Used）

## 抛掷：如何用链表来实现 LRU 缓存淘汰策略呢？

## 一，什么是链表？

1，和数组一样，链表也是一种线性表；

2，从 内存结构看， 链表 的 内存结构 是 不连续的内存空间，是将一组零散的内存块串联在一起，从而进行数据存储的数据结构；

3，链表中的每一个内存块 被称为 结点 Node。结点，除了存储数据外，还需记录上下一个结点的地址，即 前续结点 prev，后续结点 next；

## 二，为什么使用链表？链表的特点

1，插入，删除数据：效率高，时间复杂度O(1) —— 只续更改 指针指向 即可；

随机访问：效率低，时间复杂度O(n) —— 需要 从头遍历 链表；

2，和数组相比，消耗的内存空间更大，因为每个存储数据的结点都需要额外的空间存储前后结点的指针；

## 三，常用链表：单链表，循环链表和双向链表

### 1，单链表

1）每个结点只包含一个指针，即 后继指针 next

2）单链表有两个特殊的结点，即 首结点 和 尾 结点。特殊之处：用首结点地址表示整条链表，尾结点的后继指针指向 空地址 NULL

3）性能特点：插入和删除结点：时间复杂度为O(1)；查找：时间复杂度 O(n)；

### 2，循环链表

1）尾结点 的 后继指针 指向 首结点 ，其他均与单链表一致

2）适用于存储有循环特点的数据，如：约瑟夫问题

### 3，双向链表

1）结点除了存储数据外，还有两个指针分别指向 前一个结点地址(前去指针prev) 和 下一个结点地址(后续指针next)

2）首结点的 前驱指针prev 和 后继指针 均指向空地址

3）性能特点：

和单链表相比，存储相同的数据，需要消耗更多的存储空间

插入：单链表 时间复杂度 为 O(n)；双向链表 时间复杂度 为 O(1)；

>   删除场景：
>
>   1，删除结点中“值等于某个给定值”的结点；
>
>   2，删除给定指针指向的结点；

删除：

第一种情况：单链表 和 双向链表 时间复杂度 为 O(n) —— 删除 O(1)，查找 O(n)，加法法则；

第二种情况：

单链表，需要从头结点开始遍历，直到 p -> next = q，说明 p 是 q 的前驱结点，时间复杂度为 O(n)；

双向链表，指针的结点已经保存前驱结点的指针，不需要遍历，时间复杂度为 O(1)；

对于一个有序链表，双向链表的 按值查询 效率 要比单链表高一些。因为我们可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。

### 4，双向循环链表

首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。

## 四，数组，链表 如何选择？

1，插入、删除和随机访问的时间复杂度

| 时间复杂度 | 数组 | 链表 |
| ---------- | ---- | ---- |
| 插入，删除 | O(n) | O(1) |
| 随机访问   | O(1) | O(n) |

2，数组缺点

1）若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。
2）大小固定，若存储空间不足，则需进行扩容，一旦扩容就要进行数据复制，而这时非常耗时。

3，链表的缺点

1）内存空间消耗更大，因为需要额外的空间存储指针信息

2）对链表进行频繁的插入，删除操作，会导致频繁的内存申请 和 释放，容易造成内存碎片。如果是 JAVA 语言，可能会造成频繁的GC（自动垃圾回收器）操作。

4，如何选择？

-   数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高；而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。

-   如果代码对内存的使用非常苛刻，那数组就更适合。

## 五，如何用链表来实现 LRU 缓存淘汰策略呢？

思路：维护一个有序 单链表，越接近链表尾端的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表；

1，如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。

2，如果此数据没有在缓存链表中，又可以分为两种情况：

-   如果此时缓存未满，则将此结点直接插入到链表的头部，时间复杂度为 O(1)；
-   如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部，时间复杂度为 O(1)；

### 对比：数组如何实现 LRU 缓存淘汰策略 (摘自评论区，有删改)

方法一：首位置保存最新访问得数组，末位置优先清理

当访问数据未存在时，直接将数据插入数组的第一个位置，此时数组所有数据都需要往后挪一个位置，时间复杂度为 O(n)；

当访问数据存在时，找到数据并将其插入到数组的第一个位置，此时亦需要移动元素，时间复杂度为 O(n)；

方法二：首位置优先清理，末位置保存最新访问数据

当访问数据未存在时，数组容量足够，直接将数据插入到数组的末尾，时间复杂度为 O(1)；

当访问数据存在时，查找到数据并将其插入到数组的最后一位，时间复杂度为 O(1)；

缓存用满时，则清理掉数组首位置的元素，且剩余数组元素需整体前移一位，时间复杂度为 O(n)；

【优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，以提高性能。】

## 六，思考

如何判断一个字符串是否是回文字符串的问题？如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？你有什么好的解决思路呢？相应的时间空间复杂度又是多少呢？





## 拓展：

### 1，时空替换思想：“用空间换时间” 与 “用时间换空间”

当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高，时间复杂度小相对较低的算法和数据结构，缓存就是空间换时间的例子。如果内存比较紧缺，比如代码跑在手机或者单片机上，这时，就要反过来用时间换空间的思路。

对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。

### 2，Java 的 ArrayList 容器

本身支持动态扩容，但扩容进行的数据拷贝本身非常耗时

### 3，如何通过单链表实现“判断某个字符串是否为水仙花字符串”？

样例：上海自来水来自海上

1）前提：字符串以单个字符的形式存储在单链表中。

2）遍历链表，判断字符个数是否为奇数，若为偶数，则不是。

3）将链表中的字符倒序存储一份在另一个链表中。

4）同步遍历2个链表，比较对应的字符是否相等，若相等，则是水仙花字串，否则，不是。

### 4，LRU，LFU 生动描绘

LRU：活在当下。比如在公司中，一个新员工做出新业绩，马上会得到重用。

LFU：以史为镜。还是比如在公司中，新员工必须做出比那些功勋卓著的老员工更多更好的业绩才可以受到老板重视，这样的方式比较尊重“前辈”。  

### 5，练习题

练习题LeetCode对应编号：206，141，21，19，876