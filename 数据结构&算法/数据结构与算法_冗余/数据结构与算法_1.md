# 数据结构与算法



[TOC]

## 如何进行系统而高效的学习数据结构和算法？

### 一，什么是数据结构和算法？

广义：数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。

狭义：某些著名的数据结构和算法，比如队列，栈等。

经典的数据结构，是前人从很多实际的操作场景抽象出来，经过大量求证和检验，可以高效地帮助我们解决很多实际的开发问题。

数据结构是为算法服务的，算法是要作用在特定的数据结构之上。

数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上操作，构建算法，孤立存在的数据结构就是没有用的。

### 二，为什么需要数据结构和算法？

从应用层面来谈，在计算机科学和互联迅猛发展下，需要计算的数据越来越庞大，但是计算机的计算能力有限，这么大量的数据计算，需要越来越多的计算机，需要越来越长的计算时间，这无疑增大了企业公司的成本。注重效率的我们需要尽可能提高计算效率，选择合适的数据结构和算法。选用合适的数据结构和算法，特别是在处理体量非常庞大的数据时，可以极大提高计算效率。

### 三，该怎样衡量数据结构和算法？

需要引入一个衡量的标准 -- 复杂度

它是学习数据结构和算法的基石，我们需要学会 ”复杂度分析“。知道怎么分析复杂度，才能作出正确的判断，在特定的场景下选用合适的正确的算法。而不是盲目的死记烂背，机械操作。

### 四，有哪些Tips？

1，边学边练。学到的，全部都自己实现一便

2，多问，多思考，多互动。学习最好的方法，找到几个人一起学习，一块儿切磋，有问题及时寻求老师解疑。

3，打怪升级学习法。给自己设立一个切实可行的目标。

4，知识需要沉淀，不要试图一下掌握所有。学习知识的过程是反复迭代的，不断沉淀的过程。





# 复杂度分析

## 其一，如何分析，统计算法的执行效率和资源消耗？

### 一、什么是复杂度分析？

1.  数据结构和算法解决是 ”如何让代码运行得更快，如何让代码更省储存空间“
2.  这时，我们需从 执行时间 和 占用空间 两个维度来评估数据结构和算法的性能
3.  分别使用 时间复杂度 和 空间复杂度 两个概念来描述性能问题，二者统称为复杂度
4.  复杂度描述的是算法执行时间（或占用空间） 与数据规模的增长关系

### 二、为什么要进行复杂度分析？

1.  和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点
2.  通过学习复杂度分析，有助于产出效率高的程序，也有利于降低系统开发和维护成本
3.  渐进式时间，空间复杂度 只是一个理论模型，只能提供粗略的估计分析

4.  渐进式时间，空间复杂度 与 性能基准测试之间并不冲突，而是相辅相成的

### 三、如何进行复杂度分析？

#### 1，大 O 表示法

1）来源

算法的执行时间 T(n) 与每行代码的执行次数 n 成正比

>   公式 T(n) = O ( f ( n ) )

其中 T(n) 表示算法执行总时间；f（n）表示每行代码执行总次数；而 n 表示数据的规模；O 表示代码的执行时间 T(n)

2）特点

以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以 常量阶、低阶 以及 系数 实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。

复杂度也叫 渐进复杂度，包括 时间复杂度 和 空间复杂度，用来分析 算法 执行效率 与 数据规模 之间 的增长关系。

#### 2，复杂度分析法则

1）单段代码看高频：比如循环

2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度

3）嵌套代码求乘积：比如递归、多重循环等

4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加

### 四、常用的复杂度级别？

多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括：O（1）（常数阶）、O（logn）（对数阶）、O（n）（线性阶）、O（nlogn）（线性对数阶）、0（n~2）（平方阶）、0（n3）（立方阶）

非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括：O（2n）（指数阶）、O（nl）（阶乘阶）

细节：

O（logn）（对数阶）：我们忽略对数的底，同一表示为O（logn）

### 五、如何掌握好复杂度分析方法？

复杂度分析关键在于多练，所谓孰能生巧。



## 其二，浅析最好，最坏，平均，均摊时间复杂度

### 一，复杂度分析的 四个 概念

1，最坏(情况)时间复杂度：代码在最理想情况下执行的时间复杂度

2，最好(情况)时间复杂度：代码在最坏情况下执行的时间复杂度

3，平均(情况)时间复杂度：用代码在所有情况下执行的次数的加权平均值表示

4，均摊(情况)时间复杂度：在代码执行的所有复杂度情况中大部分是 最好情况时间复杂度 的，个别情况是 最坏情况时间复杂度 且 发生具有时序关系 ，可以将 个别 最坏情况时间复杂度 均摊到 最好情况时间复杂度 上，那么，一般 均摊时间复杂度 就等于 最好情况时间复杂度 。平摊是特殊的平均

### 二，为什么引入这四个概念？

1，同一段代码在不同情况下时间复杂度出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入

总结 以上 四个 概念。

2，代码复杂度在不同情况下出现两级差别是才需要却别这四种复杂度。在大多数情况下，是不需要分析他们的。

### 三，如何分析平均，均摊时间复杂度

1，平均时间复杂度

代码在不同情况下复杂度出现量级差异，则用代码所有可能情况下执行次数的 加权平均值(也叫期望值) 表示

2，均摊时间复杂度 

使用场景：1）代码在绝大数情况下是最好情况复杂度，只有极少数是最坏情况复杂度。2）最好时间复杂度和最坏时间复杂度出现具有时序规律。均摊结果一般等于最好时间复杂度。

案例解析：

分析四个复杂度

```
// 全局变量，大小为 10 的数组 array，长度 len，下标 i。
int array[] = new int[10]; 
int len = 10;
int i = 0;

// 往数组中添加一个元素
void add(int element) {
   if (i >= len) { // 数组空间不够了
     // 重新申请一个 2 倍大小的数组空间
     int new_array[] = new int[len*2];
     // 把原来 array 数组中的数据依次 copy 到 new_array
     for (int j = 0; j < len; ++j) {
       new_array[j] = array[j];
     }
     // new_array 复制给 array，array 现在大小就是 2 倍 len 了
     array = new_array;
     len = 2 * len;
   }
   // 将 element 放到下标为 i 的位置，下标 i 加一
   array[i] = element;
   ++i;
}
```

1，最好时间复杂度

有足够位置进行插入数据 —— O(1)

2，最坏时间复杂度

没有足够位置进行插入数据，数组扩容，与数组长度有关—— O(n)

3，平均时间复杂度

每次数组不够容量时，进行2倍 扩容，原数组被导入新数组，插入情况落在区间的长度与之间是一样的。分别的 0 ~ len-1，len ~ (2len - 1) ...

插入情况为 len + 1 种，0 ~ len - 1 和插满之后的 O(len)；所以每次插入的概率是：p = 1 / len + 1

最后，加权平均时间复杂度为：1\*p + 2\*p+ ▪▪▪ + len*p + len * p = O(1) ; 

4，均摊时间复杂度

由于每次O(len) 的出现都是跟着len 次 O(1)，所以，将O(len) 平摊到前len次上，得出平摊复杂度是 O(1)