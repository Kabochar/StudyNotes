# 散列表 - 实践

[TOC]

## 如何设计散列函数

1，散列函数的设计不能太复杂度。太复杂度，消耗太多计算时间，间接影响性能。

2，散列函数生成的值尽可能随机并均匀分布。避免或最小化散列冲突，平均的话可以减少某个槽内数据过多的问题。

## 装载因子过大

出现问题：装载银子越大，散列表元素越多，空闲位置越少，散列冲突的概率越大。

解决：当装载因子过大，可以进行 动态扩容，重新申请一个更大的散列表，再搬移数据。

复杂度分析：最好情况，不扩容，时间复杂度为 O(1)。最坏情况，因子过高，启动扩容，申请内存，并搬移数据，时间复杂度为 O(1)。均摊，接近最好，复杂度为 O(1)。

装载因子阀值的设置要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。

## 避免低效扩容

出现问题：搬移过程耗时严重。

解决：可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。

![1553415520824](D:\Documents\笔记本\offer学习复习\散列表\1553415520824.png)

查询操作：先查找 新散列表，如果没有找到，再去老的散列表中查找。

## 选择冲突的解决方法

主要的散列冲突的解决办法，开放寻址法和链表法。这两种冲突解决办法在实际的软件开发中都非常常用。比如，Java中LinkedHashMap就采用了链表法解决冲突，ThreadLocalMap是通过线性探测的开放寻址法来解决冲突。

1，开放寻址法

优点：

1，散列表中的数据都存储在数组中，可以有效地利用CPU缓存加快查询速度。

2，同时，这种方法实现的散列表，序列化起来比较简单。链表法包含指针，序列化起来就没那么容易。

缺点：

1，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。

2，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。

3，开放寻址法只能适用装载因子小于1的情况。接近1时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。

总结：当数据量比较小、装载因子小的时候，适合采用开放寻址法。

2，链表法

优点：

1，链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。

2，对大装载因子的容忍度更高。装载因子变成10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。

缺点：

1，链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。

2，对CPU缓存是不友好。因为链表中的结点是零散分布在内存中的，不是连续的，这方面对于执行效率也有一定的影响。

总结：基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。

## 工业级散列表分析

分析 Java 中的 HashMap

1，初始大小

初始固定 16，可自定义。如果知道数据量，可减少动态扩容的次数

2，装载因子和动态扩容

最大装载因子默认是0.75，当HashMap中元素个数超过 0.75*capacity（capacity表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。

3，散列冲突解决方法

HashMap 底层采用链表法来解决冲突。但这会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap的性能。

在JDK1.8版本中，为了对HashMap做进一步优化，我们引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高HashMap的性能。当红黑树结点个数少于8个的时候，又会将红黑树转化为链表

4，散列函数

追求简单高效

```java
int hash(Object key) {
    int h = key.hashCode()；
    return (h ^ (h >>> 16)) & (capitity -1); //capicity 表示散列表的大小
}
```

## 场景

如何设计的一个工业级的散列函数？

思考

工业级的散列表应该具有哪些特性？

-   支持快速的查询、插入、删除操作；
-   内存占用合理，不能浪费过多的内存空间；
-   性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。

从这三个方面来考虑设计思路：

-   设计一个合适的散列函数；
-   定义装载因子阈值，并且设计动态扩容策略；
-   选择合适的散列冲突解决方法。

