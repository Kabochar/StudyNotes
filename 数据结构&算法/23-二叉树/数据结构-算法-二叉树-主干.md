# 树

[TOC]

## 基础

每个元素我们叫作“节点”；用来连线相邻节点之间的关系，我们叫作“父子关系”。

比如，A节点就是B节点的父节点，B节点是A节点的子节点。B、C、D这三个节点的父节点是同一个节点，所以它们之间互称为兄弟节点。我们把没有父节点的节点叫作根节点，也就是图中的节点E。我们把没有子节点的节点叫作叶子节点或者叶节点，比如图中的G、H、I、J、K、L都是叶子节点。

![1553483773052](pics\1553483773052.png)

概念：高度（Height）、深度（Depth）、层（Level）。它们的定义是这样的：

![1553483845102](pics\1553483845102.png)

![1553483876003](pics\1553483876003.png)

“高度”这个概念，其实就是从下往上度量，比如我们要度量第10层楼的高度、第13层楼的高度，起点都是地面。

“深度”这个概念在生活中是从上往下度量的，比如水中鱼的深度，是从水平面开始度量的。

“层数”跟深度的计算类似，不过，计数起点是1，也就是说根节点的位于第1层。

## 二叉树

定义：每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。

![1553484822445](pics\1553484822445.png)

编号2的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作满二叉树。

编号3的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二又树叫作完全二叉树。

![1553484787786](pics\1553484787786.png)

### 如何存储一棵二叉树

两种方式：一种，基于指针或者引用的二叉链式存储法，一种，基于数组的顺序存储法。

链式存储法：从图中你应该可以很清楚地看到，每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。

![1553484916730](pics\1553484916730.png)

基于数组的顺序存储法。我们把根节点存储在下标 i=1的位置，那左子节点存储在下标 2\*i=2的位置，右子节点存储在 2\*i+1=3的位置。以此类推，B节点的左子节点存储在 2\*i=2\*2=4的位置，右子节点存储在 2\*i+1=2\*2+1=5的位置。

总结一下，如果节点X存储在数组中下标为i的位置，下标为2*i的位置存储的就是左子节点，下标为2*i+1的位置存储的就是右子节点。反过来，下标为i/2的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为1的位置），这样就可以通过下标计算，把整棵树都串起来。

![1553484934241](pics\1553484934241.png)

非完全二叉树，其实会浪费比较多的数组存储空间。某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。

### 二叉树的遍历

经典三种遍历方式：前序遍历、中序遍历和后序遍历。其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。

-   前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。
-   中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。
-   后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。

![1553485363255](pics\1553485363255.png)

二叉树的前、中、后序遍历就是一个递归的过程。比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。

递归代码关键，能不能写出递推公式

```
前序遍历的递推公式：
preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)

中序遍历的递推公式：
inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)

后序遍历的递推公式：
postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r
```

遍历代码

```
void preOrder(Node* root) {
  if (root == null) return;
  print root // 此处为伪代码，表示打印 root 节点
  preOrder(root->left);
  preOrder(root->right);
}

void inOrder(Node* root) {
  if (root == null) return;
  inOrder(root->left);
  print root // 此处为伪代码，表示打印 root 节点
  inOrder(root->right);
}

void postOrder(Node* root) {
  if (root == null) return;
  postOrder(root->left);
  postOrder(root->right);
  print root // 此处为伪代码，表示打印 root 节点
}
```

### 复杂度分析

时间复杂度：O(n)，每个节点最多会被访问两次，所以，遍历的时间复杂度跟节点个数成正比。 

### 场景

1，给定一组数据，比如1，3，5，6，9，10。你来算算，可以构建出多少种不同的二又树？

既然是数组了，说明是完全二叉树，应该有n的阶乘个组合。

2，我们讲了三种二叉树的遍历方式，前、中、后序。实际上，还有另外一种遍历方式，也就是按层遍历，你知道如何实现吗？

二叉树按层遍历，可以看作以根结点为起点，图的广度优先遍历的问题。

## 二叉查找树

二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。

最大的特点：支持动态数据集合的快速插入、删除、查找操作。

定义：二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要 小于 这个节点的值，而右子树节点的值都 大于 这个节点的值。我画了几个二叉查找树的例子，你一看应该就清楚了。

1，查找操作

先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。

```java
public Node find(int data) {
    Node p = tree;
    while (p != null) {
        if (data < p.data) p = p.left;
        else if (data > p.data) p = p.right;
        else return p;
    }
    return null;
}
```

2，插入操作

新插入的数据一般都是在叶子节点上，所以，只需要从根节点开始，依次比较要插入的数据和节点的大小关系。

如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。

```
public void insert(int data) {
  if (tree == null) {
    tree = new Node(data);
    return;
  }

  Node p = tree;
  while (p != null) {
    if (data > p.data) {
      if (p.right == null) {
        p.right = new Node(data);
        return;
      }
      p = p.right;
    } else { // data < p.data
      if (p.left == null) {
        p.left = new Node(data);
        return;
      }
      p = p.left;
    }
  }
}
```

3，删除操作

针对要删除节点的子节点个数的不同，分三种情况来处理：

第一种情况，如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为nul。比如图中的删除节点55。

第二种情况，如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点13。

第三种情况，如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点18。

![1553486173334](pics\1553486173334.png)

```
public void delete(int data) {
  Node p = tree; // p 指向要删除的节点，初始化指向根节点
  Node pp = null; // pp 记录的是 p 的父节点
  while (p != null && p.data != data) {
    pp = p;
    if (data > p.data) p = p.right;
    else p = p.left;
  }
  if (p == null) return; // 没有找到

  // 要删除的节点有两个子节点
  if (p.left != null && p.right != null) { // 查找右子树中最小节点
    Node minP = p.right;
    Node minPP = p; // minPP 表示 minP 的父节点
    while (minP.left != null) {
      minPP = minP;
      minP = minP.left;
    }
    p.data = minP.data; // 将 minP 的数据替换到 p 中
    p = minP; // 下面就变成了删除 minP 了
    pp = minPP;
  }

  // 删除节点是叶子节点或者仅有一个子节点
  Node child; // p 的子节点
  if (p.left != null) child = p.left;
  else if (p.right != null) child = p.right;
  else child = null;

  if (pp == null) tree = child; // 删除的是根节点
  else if (pp.left == p) pp.left = child;
  else pp.right = child;
}
```

删除操作，还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉。

4，其他操作

快速地查找最大节点和最小节点、前驱节点和后继节点

中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是O（n），非常高效

## 支持重复数据的二叉查找树

如果存储的两个对象键值相同，这种情况该怎么处理呢？

有两种解决方法。

第一种方法，二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。

第二种方法，比较不好理解，但优雅。每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。

![1553486454831](pics\1553486454831.png)

查找数据：遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。

![1553486503076](pics\1553486503076.png)

删除操作：我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。

### 复杂度分析

复杂度：O(n)。图中第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了链表

![1553492656902](pics\1553492656902.png)

最理想的情况

二叉查找树，一棵完全二叉树（或满二叉树）。

时间复杂度：O（height）。那，如何求一棵包含n个节点的完全二叉树的高度？

树的高度就等于最大层数减一，为了方便计算，我们转换成层来表示。下面一层节点个数是上一层的2倍，第 K 层包含的节点个数就是2（K-1）。

### 场景

相对散列表，那我们为什么还要用二又查找树呢？

有下面几个原因：

1，散列的数据是无序的。

散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在O（n）的时间复杂度内，输出有序的数据序列。

2，散列扩容耗时较长。

散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在O（logn）。

3，处理效率上，散列不及平衡二叉树。

笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比logn小，所以实际的查找速度可能不一定比O（logn）快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。

4，设计散列需要考虑的元素较多，不适合工程使用。

散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。

最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。



## 如何通过编程，求出一棵给定二叉树的确切高度呢？

其一

递归法，根节点高度=max(左子树高度，右子树高度)+1

其二

确定二叉树高度有两种思路：

第一种是深度优先思想的递归，分别求左右子树的高度。当前节点的高度就是左右子树中较大的那个+1；

第二种可以采用层次遍历的方式，每一层记录都记录下当前队列的长度，这个是队尾，每一层队头从0开始。然后每遍历一个元素，队头下标+1。直到队头下标等于队尾下标。这个时候表示当前层遍历完成。每一层刚开始遍历的时候，树的高度+1。最后队列为空，就能得到树的高度。