# 排序

[TOC]

## 如何分析 排序算法

### 执行效率

1，最好、最坏、平均情况时间复杂度

2，时间复杂度的系数、常数、低阶

3，比较次数、交换（移动）次数

### 内存消耗

原地排序（Sorted in place）：特指空间复杂度是O（1）的排序算法。

### 稳定性

如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

## 冒泡排序

操作：每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如不满足就让它俩互换。一次冒泡至少一个元素进行移动，重复 n 次，就完成了 n 个数据的排序工作。

### 分析

1，原地排序：只涉及相邻元素的交换操作，只需要 常量级临时空间，空间复杂度 O(1)

2，稳定性：只有交换才可以改变两个元素的前后顺序，当大小相等，不做操作。

3，时间复杂度：最好 O(n) 进行一次操作，最坏 O(n<sup>2</sup>) - 数据倒序，平均 O(n<sup>2</sup>)

### 有序度，无序度

有序度：数组中具有  有序关系 的元素对的个数。

```
有序元素对：a[i] <= a[j], 如果 i < j。
```

对于一个完全有序的数组，比如 {1，2，3，4，5，6}，有序度就是 n *（n-1）/ 2

逆序度：逆序度 = 满有序度 - 有序度

我们排序的过程就是一种 增加有序度，减少逆序度 的过程，最后达到满有序度，就说明排序完成了。

冒泡排序包含两个操作原子，比较和交换。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为 逆序度，也就是 `n *（n-1）/ 2 `初始有序度。

## 插入排序

实现原理：取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

基本操作：元素的交换，移动

![1555343370897](pics\1555343370897.png)

### 分析

1，原地排序：不需要额外的存储空间，空间复杂度 O(1)

2，稳定性：对于值相同的，可以插到前面出现元素的后面。

3，时间复杂度：最好 O(n) - 遍历一次，最坏 O(n<sup>2</sup>) - 数据倒序，平均 O(n<sup>2</sup>)

## 选择排序

实现原理：每次会从未排序区间中找到最小的元素，将其放到已排序区间的未尾。

![1555343717037](pics\1555343717037.png)

### 分析

1，原地排序：不需要额外的存储空间，空间复杂度O(1)

2，稳定性：对于值相同的，可以插到前面出现元素的后面。

3，时间复杂度：最好 O(n<sup>2</sup>)- 每次都需要查找最小元素，最坏 O(n<sup>2</sup>) - 数据倒序，平均 O(n<sup>2</sup>)

## 选择比冒泡使用更广泛

1，元素交换次数相同，都为 数据的逆序度。

2，冒泡排序需要3个赋值操作，而插入排序只需要1个。

## 归并排序

实现原理：先把 数组 分成前后两个部分，然后对前后两个部分分别排序，再将排好的两部分合并在一起，这样整个数组就都有序了。

````
// 归并排序算法, A 是数组，n 表示数组大小
merge_sort(A, n) {
	merge_sort_c(A, 0, n-1)
}

// 递归调用函数
merge_sort_c(A, p, r) {
    // 递归终止条件
    if p >= r  then return

    // 取 p 到 r 之间的中间位置 q
    q = (p+r) / 2
    // 分治递归
    merge_sort_c(A, p, q)
    merge_sort_c(A, q+1, r)
    // 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]
    merge(A[p...r], A[p...q], A[q+1...r])
}
````

merge() 函数实现过程：，我们申请一个临时数组 tmp，大小与 A[p...r] 相同。我们用两个游标i和j，分别指向 A[p...q] 和 A[q+1..r] 的第一个元素。比较这两个元素 A[i] 和 A[j]，如果 A[i] <= A[j]，我们就把 A[i] 放入到临时数组 tmp，并且 i 后移一位，否则将 A[j] 放入到 数组 tmp，j 后移一位。

![1553327238454](pics\1553327238454.png)

```
merge(A[p...r], A[p...q], A[q+1...r]) {
    var i := p，j := q+1，k := 0 // 初始化变量 i, j, k
    var tmp := new array[0...r-p] // 申请一个大小跟 A[p...r] 一样的临时数组
    while i<=q AND j<=r do {
        if A[i] <= A[j] {
        	tmp[k++] = A[i++] // i++ 等于 i:=i+1
        } else {
        	tmp[k++] = A[j++]
        }
    }

    // 判断哪个子数组中有剩余的数据
    var start := i，end := q
    if j<=r then start := j, end:=r

    // 将剩余的数据拷贝到临时数组 tmp
    while start <= end do {
    	tmp[k++] = A[start++]
    }

    // 将 tmp 中的数组拷贝回 A[p...r]
    for i:=0 to r-p do {
    	A[p+i] = tmp[i]
    }
}
```

### 分析

1，稳定性：稳定性需要看 merge 函数。归并是稳定的排序算法。

2，时间复杂度：O(nlog n)。时间复杂度稳定，最好，最坏，平均，都是 O(nlog n)

3，空间复杂度：O(n)。不是原地排序算法。合并操作需要申请额外的内存空间，在合并完成后，它又会被释放掉。任意时刻，CPU 只会有一个函数在执行，也就是，只有一个临时的内存空间在使用。

## 快速排序

实现原理：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。

根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。

![1553327978786](pics\1553327978786.png)

```
// 快速排序，A 是数组，n 表示数组的大小
quick_sort(A, n) {
    quick_sort_c(A, 0, n-1)
}
// 快速排序递归函数，p,r 为下标
quick_sort_c(A, p, r) {
    if p >= r then return

    q = partition(A, p, r) // 获取分区点
    quick_sort_c(A, p, q-1)
    quick_sort_c(A, q+1, r)
}
```

原地分区函数的实现思路非常巧妙，partition() 函数

```
partition(A, p, r) {
    pivot := A[r]
    i := p
    for j := p to r-1 do {
    	if A[j] < pivot {
            swap A[i] with A[j]
            i := i+1
        }
    }
    swap A[i] with A[r]
    return i
}
```

![1553328447284](pics\1553328447284.png)

分析：

1，时间复杂度：O(nlogn)。极少数情况出现O(n<sup>2</sup>)

## 归并排序 快速排序区别

![1553328718851](pics\1553328718851.png)

归并排序的处理是由下到上，先处理子问题，再合并。稳定的，时间复杂度为 O(nlog n)，非原地排序。

快排的处理是由上到下，先分区，然后再处理子问题。可实现原地排序，较少内存消耗。

## 桶排序

实现原理：将要排序的数据分到几个有序的桶里。每个桶里的数据在单独进行排序，桶内排完序后，在把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

### 分析

时间复杂度：O(n)

使用利弊：对排序数据要求苛刻。比较适合使用在外部排序中（数据量大，内存有限）

## 计数排序

实现原理：计数排序是桶排序的一种特殊情况。当要排序的 n个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。

利弊：计数排序只能用在数据范围不大的场景中，如果数据范围k 比要排序的数据 n大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。

## 计数排序

利弊：基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果a数据的高位比b数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到O（n）了。

## 如何实现一个通用的排序算法？

![1553330115056](./pics\1553330115056.png)

如何优化快速排序？

快排中出现O(n<sup>2</sup>) 的原因：分区点选择不合理。

如何解决？最理想的是：被分区分开的两个分区中，数据的数量差不多。

常用的分区算法：

1，三数取中法

我们从区间的首、尾、中间，分别取出一个数，然后对比大小，取这3个数的中间值作为分区点。

但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。

2，随机法

随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。

## 排序函数实例

拿Glibc中的qsort（）函数举例说明一下。

qsort（）会优先使用归并排序来排序输入数据，因为归并排序的空间复杂度是O（n）。

要排序的数据量比较大的时候，qsort（）会改为用快速排序算法来排序。

qsort（）还用到了插入排序。在快速排序的过程中，当要排序的区间中，元素的个数小于等于4时，qsort（）就退化为插入排序，不再继续用递归来做快速排序，因为我们前面也讲过，在小规模数据面前，o（n2）时间复杂度的算法并不一定比O（nlogn）的算法执行时间长。

## Golang 的 Sort

golang标准库中的 Sort 用的是 快排 + 希尔排序 + 插排，数据量大于 12时用快排，小于等于 12时，用 6 作为 gap 做一次希尔排序，然后走一遍普通的插排（插排对有序度高的序列效率高）。其中快排 pivot 的选择做了很多工作不是一两句话可以描述出来，是基于首中尾中值的很复杂的变种。