# 哈希算法 - 主干

[TOC]

## 基础

定义：将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法。通过原始数据映射之后得到的二进制值串就是哈希值。

### 设计优秀哈希算法的要求

-   从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；
-   对输入数据非常敏感，哪怕原始数据只修改了一个Bit，最后得到的哈希值也大不相同；
-   散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；（“散列冲突”的数学原理是鸽巢原理）
-   哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。

注意：无论哈希的文本多长，多短，通过 MD5 哈希之后，得到的哈希值的长度都是相同的。

## 哈希算法的应用

### 应用一：安全加密

常用加密算法：MD5（MD5 Message-Digest Algorithm，MD5消息摘要算法），SHA（Secure Hash Algorithm，安全散列算法）。

对用于加密的哈希算法来说，有两点格外重要：

第一点，很难根据哈希值反向推导出原始数据；加密的目的就是防止原始数据泄露，所以很难通过哈希值反向推导原始数据，这是一个最基本的要求。

第二点，散列冲突的概率要很小。不管是什么哈希算法，我们只能尽量减少碰撞冲突的概率，理论上是没办法做到完全不冲突的。因为哈希值是固定的 128位二进制串，最多能标识 2 的 128次方，但 使用哈希的数据是无穷的。

没有绝对的安全加密，越复杂，计算时间也越长。

### 应用二：唯一标识

如何比较图片？可以给每一个图片取一个唯一标识，或者是信息摘要。

我们可以从图片的二进制码串开头取100个字节，从中间取100个字节，从最后再取100个字节，然后将这300个字节放到一块，通过哈希算法（比如MD5），得到一个哈希字符串，用它作为图片的唯一标识。

想继续提高效率，我们可以把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中。

如果不存在，那就说明这个图片不在图库中；如果存在，我们再通过散列表中存储的文件路径，获取到这个已经存在的图片，跟现在要插入的图片做全量的比对，看是否完全一样。如果一样，就说明已经存在；如果不一样，说明两张图片尽管唯一标识相同，但是并不是相同的图片。

### 应用三：数据校验

根据哈希算法的特点，数据有一丁点的改动，哈希值就会有很大的不同。

可以使用在 BT 网络传输文件的检验上。

### 应用四：散列函数

散列函数是设计一个散列表的关键，它直接决定了散列冲突的概率和散列表的性能。

相对哈希算法的其他应用，散列函数对于散列算法冲突的要求要低很多。即便出现个别散列冲突，只要不是过于严重，我们都可以通过开放寻址法或者链表法解决。

散列函数对于散列算法计算得到的值，是否能反向解密也并不关心。

散列函数中用到的散列算法，更加关注散列后的值是否能平均分布，也就是，一组数据是否能均匀地散列在各个槽中。

### 应用五：负载均衡

负载均衡算法有很多，比如轮询、随机、加权轮询等。

如何才能实现一个会话粘滞（session sticky）的负载均衡算法呢？也就是说，我们需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。

最直接的方法就是，维护一张映射关系表，这张表的内容是客户端IP地址或者会话ID与服务器编号的映射关系。

弊端

-   如果客户端很多，映射表可能会很大，比较浪费内存空间；
-   客户端下线、上线，服务器扩容、缩容都会导致映射失效，这样维护映射表的成本就会很大；

通过哈希算法，对客户端 IP 地址或者 会话 ID 计算哈希值，将取得的哈希值与服务列表的大小进行去摸运算，最终得到的值就是应该被路由到的服务器编号。

### 应用六：数据分片

1，如何统计“搜索关键词”出现的次数？

难点：第一个难点，搜索日志很大，没办法放到一台机器的内存中；第二个难点，如果只用一台机器来处理这么巨大的数据，处理时间会很长。

解决：可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。

思路：提高处理的速度，我们用n台机器并行处理。我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟n取模，最终得到的值，就是应该被分配到的机器编号。（MapReduce 基本设计思想）同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。

2，如何快速判断图片是否在图库中？

难点：单台机器的内存有限，而1亿张图片构建散列表显然远远超过了单台机器的内存上限。

解决：多机处理。

思路：我们准备n台机器，让每台机器只维护某一部分图片对应的散列表。我们每次从图库中读取一个图片，计算唯一标识，然后与机器个数n求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。
当我们要判断一个图片是否在图库中的时候，我们通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数n求余取模。假设得到的值是k，那就去编号k的机器构建的散列表中查找。

<details>
<summary>机器资源量计算</summary>
<p>散列表中每个数据单元包含两个信息，哈希值和图片文件的路径。假设我们通过MD5来计算哈希值，那长度就是128比特，也就是16字节。文件路径长度的上限是256字节，我们可以假设平均长度是128字节。如果我们用链表法来解决冲突，那还需要存储指针，指针只占用8字节。所以，散列表中每个数据单元就占用152字节（这里只是估算，并不准确）。
</p>
<p>假设一台机器的内存大小为2GB，散列表的装载因子为0.75，那一台机器可以给大约1000万（2GB*0.75/152）张图片构建散列表。所以，如果要对1亿张图片构建索引，需要大约十几台机器。在工程中，这种估算还是很重要的，能让我们事先对需要投入的资源、资金有个大概的了解，能更好地评估解决方案的可行性。
</p>
<p>
实际上，针对这种海量数据的处理问题，我们都可以采用多机分布式处理。借助这种分片的思路，可以突破单机内存、CPU等资源的限制。
</p>
</details>

### 应用七：分布式存储

难点：海量数据，海量用户

解决：通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号。

扩容难点：所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。缓存中的数据一下子就都失效了。所有的数据请求都会穿透缓存，直接去请求数据库。这样就可能发生雪崩效应，压垮数据库。

解决：使用一致性哈希算法。假设我们有 k 个机器，数据的哈希值的范围是 [0，MAX]。我们将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m / k 个小区间。当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。

link http://www.zsythink.net/archives/1182

## 场景

脱库，字典攻击。针对字典攻击，可以引入一个 盐，跟用户密码组合在一起，增加密码的复杂度。

### 区块链的实现？

 区块链是一块块区块组成的，每个区块分为两部分：区块头和区块体。

区块头保存着 自己区块体 和 上一个区块头 的哈希值。

因为这种链式关系和哈希值的唯一性，只要区块链上任意一个区块被修改过，后面所有区块保存的哈希值就不对了。

区块链使用的是 SHA256 哈希算法，计算哈希值非常耗时，如果要篡改一个区块，就必须重新计算该区块后面所有的区块的哈希值，短时间内几乎不可能做到。  