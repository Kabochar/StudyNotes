# InnoDB记录存储结构

表中的数据到底存到了哪里？

以什么格式存放的？

`MySQL`是以什么方式来访问的这些数据？

## InnoDB页简介

真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。

`InnoDB`采取的方式是：将数据划分为若干个  页，以  页 作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 ***16*** KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。

## InnoDB行格式

平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为`行格式`或者`记录格式`。

设计`InnoDB`存储引擎的大叔们到现在为止设计了4种不同类型的`行格式`，分别是`Compact`、`Redundant`、`Dynamic`和`Compressed`行格式。

### 指定行格式的语法

创建或修改表的语句中指定`行格式`：

```
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
    
ALTER TABLE 表名 ROW_FORMAT=行格式名称
```

### COMPACT行格式

![1559979464729](pics\1559979464729.png)

一条完整的记录其实可以被分为`记录的额外信息`和`记录的真实数据`两大部分

#### 记录的额外信息

这部分信息是服务器为了描述这条记录而不得不额外添加的一些信。

这些额外信息分为3类，分别是`变长字段长度列表`、`NULL值列表`和`记录头信息`。

##### 变长字段长度列表

变长字段占用的存储空间分为两部分：

1.  真正的数据内容
2.  占用的字节数

在`Compact`行格式中，把所有变长字段的真实数据  占用的字节长度  都存放在记录的 开头部位，从而形成一个变长字段长度列表，各变长字段数据  占用的字节数  按照  列的顺序  逆序 存放

`InnoDB`有它的一套规则，我们首先声明一下`W`、`M`和`L`的意思：

1.  假设某个字符集中表示一个字符最多需要使用的字节数为`W`，也就是使用`SHOW CHARSET`语句的结果中的`Maxlen`列，比方说`utf8`字符集中的`W`就是`3`，`gbk`字符集中的`W`就是`2`，`ascii`字符集中的`W`就是`1`。
2.  对于变长类型`VARCHAR(M)`来说，这种类型表示能存储最多`M`个字符（注意是字符不是字节），所以这个类型能表示的字符串最多占用的字节数就是`M×W`。
3.  假设它实际存储的字符串占用的字节数是`L`。

总结一下就是说：如果该可变字段允许存储的最大字节数（`M×W`）超过255字节并且真实存储的字节数（`L`）超过127字节，则使用2个字节，否则使用1个字节。

变长字段长度列表中只存储值为 ***非NULL*** 的列内容占用的长度，值为 ***NULL*** 的列的长度是不储存的 。

>    并不是所有记录都有这个 变长字段长度列表 部分，比方说表中所有的列都不是变长的数据类型的话，这一部分就不需要有。

##### NULL值列表

`Compact`行格式把这些值为`NULL`的列统一管理起来，存储到`NULL`值列表中，它的处理过程是这样的：

1.  首先统计表中允许存储`NULL`的列有哪些。

2.  如果表中没有允许存储 ***NULL*** 的列，则 *NULL值列表* 也不存在了，否则将每个允许存储`NULL`的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：
    -   二进制位的值为`1`时，代表该列的值为`NULL`。
    -   二进制位的值为`0`时，代表该列的值不为`NULL`。

3.  `MySQL`规定`NULL值列表`必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补`0`。

##### 记录头信息

用于描述记录的`记录头信息`，它是由固定的`5`个字节组成。

`5`个字节也就是`40`个二进制位，不同的位代表不同的意思，如图：

![1559980419167](pics\1559980419167.png)

#### 记录的真实数据

除了我们自己定义的列的数据以外，`MySQL`会为每个记录默认的添加一些列（也称为`隐藏列`），具体的列如下：

|       列名       | 是否必须 | 占用空间 |          描述          |
| :--------------: | :------: | :------: | :--------------------: |
|     `row_id`     |    否    | `6`字节  | 行ID，唯一标识一条记录 |
| `transaction_id` |    是    | `6`字节  |         事务ID         |
|  `roll_pointer`  |    是    | `7`字节  |        回滚指针        |

InnoDB存储引擎会为每条记录都添加 ***transaction_id*** 和 ***roll_pointer*** 这两个列，但是 ***row_id*** 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。

>   这些隐藏列的值不用我们操心，`InnoDB`存储引擎会自己帮我们生成的。

#### CHAR(M)列的存储格式

对于 ***CHAR(M)*** 类型的列来说：

-   当列采用的是  定长 字符集时，该列占用的字节数不会被加到变长字段长度列表，

-   如果采用  变长 字符集时，该列占用的字节数也会被加到变长字段长度列表。

变长字符集的`CHAR(M)`类型的列要求至少占用`M`个字节，而`VARCHAR(M)`却没有这个要求。

### Redundant行格式

`MySQL5.0`之前用的一种行格式

![1559980619102](pics\1559980619102.png)

`Redundant`行格式有什么不同的地方：

-   字段长度偏移列表

    注意`Compact`行格式的开头是`变长字段长度列表`，而`Redundant`行格式的开头是`字段长度偏移列表`，与`变长字段长度列表`有两处不同：

    -   没有了  变长 两个字，意味着`Redundant`行格式会把该条记录中所有列（包括`隐藏列`）的长度信息都按照逆序存储到`字段长度偏移列表`。
    -   多了个  偏移 两个字，这意味着计算列值长度的方式不像`Compact`行格式那么直观，它是采用两个相邻数值的差值来计算各个列值的长度。

-   记录头信息

    `Redundant`行格式的记录头信息占用`6`字节，`48`个二进制位，这些二进制位代表的意思如下：

    与`Compact`行格式的记录头信息对比来看，有两处不同：

    -   `Redundant`行格式多了`n_field`和`1byte_offs_flag`这两个属性。
    -   `Redundant`行格式没有`record_type`这个属性。

-   `1byte_offs_flag`的值是怎么选择的

    `字段长度偏移列表`实质上是存储每个列中的值占用的空间在`记录的真实数据`处结束的位置

    那到底什么时候用1个字节，什么时候用2个字节呢？其实是根据该条`Redundant`行格式`记录的真实数据`占用的总大小来判断的：

    直接使用整个`记录的真实数据`长度来决定使用  1个字节还是  2个字节存储列对应的偏移量。只要整条记录的真实数据占用的存储空间大小大于  127，即使第一个列的值占用存储空间小于  127，那对不起，也需要使用   2个字节来表示该列对应的偏移量。

    为了在解析记录时知道每个列的偏移量是使用  1个字节还是  2个字节表示的，设计`Redundant`行格式的大叔特意在`记录头信息`里放置了一个称之为`1byte_offs_flag`的属性：

    -   当它的值为  1时，表明使用  1个字节存储。
    -   当它的值为  0时，表明使用  2个字节存储。

-   `Redundant`行格式中`NULL`值的处理

    在解析一条记录的某个列时，首先看一下该列对应的偏移量的`NULL比特位`是不是为`1`，如果为`1`，那么该列的值就是`NULL`，否则不是`NULL`。

    这也就解释了上边介绍为什么只要记录的真实数据大于127（十六进制`0x7F`，二进制`01111111`）时，就采用2个字节来表示一个列对应的偏移量。

    主要是第一个比特位是所谓的`NULL比特位`，用来标记该列的值是否为`NULL`。

    对于值为`NULL`的列来说，该列的类型是否为定长类型决定了`NULL`值的实际存储方式

    分情况看一下：

    -   如果存储`NULL`值的字段是定长类型的，比方说`CHAR(M)`数据类型的，则`NULL`值也将占用记录的真实数据部分，并把该字段对应的数据使用`0x00`字节填充。
    -   如果该存储`NULL`值的字段是变长数据类型的，则不在`记录的真实数据`处占用任何存储空间。

#### CHAR(M)列的存储格式

`Compact`行格式在`CHAR(M)`类型的列中存储数据的时候还挺麻烦，分变长字符集和定长字符集的情况

`Redundant`行格式中十分干脆，不管该列使用的字符集是啥，只要是使用`CHAR(M)`类型，占用的真实数据空间就是该字符集表示一个字符最多需要的字节数和`M`的乘积

### 行溢出数据

#### VARCHAR(M)最多能存储的数据

`VARCHAR(M)`类型的列最多可以占用`65535`个字节。其中的`M`代表该类型最多存储的字符数量，如果我们使用`ascii`字符集的话，一个字符就代表一个字节。

这个`65535`个字节除了列本身的数据之外，还包括一些其他的数据（`storage overhead`），比如说我们为了存储一个`VARCHAR(M)`类型的列，其实需要占用3部分存储空间：

-   真实数据
-   真实数据占用字节的长度
-   `NULL`值标识，如果该列有`NOT NULL`属性则可以没有这部分存储空间

如果该`VARCHAR`类型的列没有`NOT NULL`属性，那最多只能存储`65532`个字节的数据，因为真实数据的长度可能占用2个字节，`NULL`值标识需要占用1个字节：



如果`VARCHAR`类型的列有`NOT NULL`属性，那最多只能存储`65533`个字节的数据，因为真实数据的长度可能占用2个字节，不需要`NULL`值标识：

如果`VARCHAR(M)`类型的列使用的不是`ascii`字符集，那`M`的最大取值取决于该字符集表示一个字符最多需要的字节数。

>   小贴士： 上述所言在列的值允许为NULL的情况下，
>
>   gbk字符集下M的最大取值就是32766，
>
>   utf8字符集下M的最大取值就是21844，
>
>   这都是在表中只有一个字段的情况下说的，一定要记住一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节！

#### 记录中的数据太多产生的溢出

在`Compact`和`Reduntant`行格式中，对于占用存储空间非常大的列，在`记录的真实数据`处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后`记录的真实数据`处用20个字节存储指向这些页的地址，从而可以找到剩余数据所在的页

不只是 ***VARCHAR(M)*** 类型的列，其他的 ***TEXT***、***BLOB*** 类型的列在存储数据非常多的时候也会发生`行溢出`。

![1559981208907](pics\1559981208907.png)

#### 行溢出的临界点

一个页一般是`16KB`，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种现象称为`行溢出`。

你不用关注这个临界点是什么，只要知道如果我们一条记录的某个列中存储的数据占用的字节数非常多时，该列就可能成为`溢出列`。

### Dynamic和Compressed行格式

它们不会在记录的真实数据处存储字段真实数据的前`768`个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。

![1559981266054](pics\1559981266054.png)

`Compressed`行格式和`Dynamic`不同的一点是，`Compressed`行格式会采用压缩算法对页面进行压缩，以节省空间。

## 总结

1.  页是`MySQL`中磁盘和内存交互的基本单位，也是`MySQL`是管理存储空间的基本单位。

2.  指定和修改行格式的语法如下：

    ```
    CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
    
    ALTER TABLE 表名 ROW_FORMAT=行格式名称
    ```

3.  `InnoDB`目前定义了4种行格式

    -   COMPACT行格式

        具体组成如图：

        ![image_1c9g4t114n0j1gkro2r1h8h1d1t16.png-42.4kB](https://user-gold-cdn.xitu.io/2019/3/12/169710e8fafc21aa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

        

    -   Redundant行格式

        具体组成如图：

        ![image_1ctfppb4c1cng1m8718l91760jde9.png-36.2kB](https://user-gold-cdn.xitu.io/2019/3/12/169710e9ca9cbeb5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

        

    -   Dynamic和Compressed行格式

        这两种行格式类似于`COMPACT行格式`，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字符串的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。

        另外，`Compressed`行格式会采用压缩算法对页面进行压缩。

-   一个页一般是`16KB`，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种现象称为`行溢出`。