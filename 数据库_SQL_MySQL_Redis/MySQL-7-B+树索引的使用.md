# B+树索引的使用

[TOC]

## 前情

`InnoDB`存储引擎的`B+`树索引，我们必须熟悉下边这些结论：

-   每个索引都对应一棵`B+`树，`B+`树分为好多层，最下边一层是叶子节点，其余的是内节点。所有`用户记录`都存储在`B+`树的叶子节点，所有`目录项记录`都存储在内节点。
-   `InnoDB`存储引擎会自动为主键（如果没有它会自动帮我们添加）建立`聚簇索引`，聚簇索引的叶子节点包含完整的用户记录。
-   我们可以为自己感兴趣的列建立`二级索引`，`二级索引`的叶子节点包含的用户记录由`索引列 + 主键`组成，所以如果想通过`二级索引`来查找完整的用户记录的话，需要通过`回表`操作，也就是在通过`二级索引`找到主键值之后再到`聚簇索引`中查找完整的用户记录。
-   `B+`树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是`联合索引`的话，则页面和记录先按照`联合索引`前边的列排序，如果该列值相同，再按照`联合索引`后边的列排序。
-   通过索引查找记录是从`B+`树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了`Page Directory`（页目录），所以在这些页面中的查找非常快。

## 索引的代价

虽然索引是个好东西，可不能乱建。

-   空间上的代价

    每建立一个索引都要为它建立一棵`B+`树，每一棵`B+`树的每一个节点都是一个数据页，一个页默认会占用`16KB`的存储空间，一棵很大的`B+`树由许多数据页组成，那可是很大的一片存储空间呢。

-   时间上的代价

    存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序。

一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。

## B+树索引适用的条件

-   表中的主键是`id`列，它存储一个自动递增的整数。所以`InnoDB`存储引擎会自动为`id`列建立聚簇索引。
-   额外定义了一个二级索引`idx_name_birthday_phone_number`。在这个索引对应的`B+`树的叶子节点处存储的用户记录只保留`name`、`birthday`、`phone_number`这三个列的值以及主键`id`的值，并不会保存`country`列的值。

```
CREATE TABLE person_info(
    id INT NOT NULL auto_increment,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
```

例子：

![1565421862252](pics\1565421862252.png)

从图中可以看出，这个`idx_name_birthday_phone_number`索引对应的`B+`树中页面和记录的排序方式就是这样的：

-   先按照`name`列的值进行排序。
-   如果`name`列的值相同，则按照`birthday`列的值进行排序。
-   如果`birthday`列的值也相同，则按照`phone_number`的值进行排序。

只要页面和记录是排好序的，我们就可以通过二分法来快速定位查找。

### 全值匹配

如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配。

```
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239';
```

按照建立的`idx_name_birthday_phone_number`索引次序进行

### 匹配左边的列

语句按照这样排列，才能进行索引 `idx_name_birthday_phone_number`

在我们的搜索语句中也可以不用包含全部联合索引中的列，只包含左边的就行

```
SELECT * FROM person_info WHERE name = 'Ashburn';
```

或者包含多个左边的列也行：

```
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27';
```

注意，必须出现左边的列才可以使用到这个`B+`树索引，以下无法使用

```
SELECT * FROM person_info WHERE birthday = '1990-09-27';
```

So？如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列。

### 匹配列前缀

前言，一个排好序的字符串列其实有这样的特点：

-   先按照字符串的第一个字符进行排序。
-   如果第一个字符相同再按照第二个字符进行排序。
-   如果第二个字符相同再按照第三个字符进行排序，依此类推。

想查询名字以`'As'`开头的记录，那就可以这么写查询语句，这样可以使用到索引了：

```
SELECT * FROM person_info WHERE name LIKE 'As%';
```

### 匹配范围值

所有记录都是按照索引列的值从小到大的顺序排好序的

```
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

执行过程：

-   找到`name`值为`Asa`的记录
-   找到`name`值为`Barlow`的记录
-   所有记录都是由链表连起来的（记录之间用单链表，数据页之间用双链表），快速提取
-   找到这些记录的主键值，再到`聚簇索引`中`回表`查找完整的记录。

如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到`B+`树索引，以下只是使用到了 name 索引

```
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' AND birthday > '1980-01-01';
```

### 精确匹配某一列并范围匹配另外一列

对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找

```
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday > '1980-01-01' AND birthday < '2000-12-31' AND phone_number > '15100000000';
```

### 用于排序

在`MySQL`中，把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：`filesort`），跟`文件`这个词儿一沾边儿，就显得这些排序操作非常慢了（磁盘和内存的速度比起来，就像是飞机和蜗牛的对比）。

如果`ORDER BY`子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤，比如下边这个简单的查询语句：

```
SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;
```

`B+`树索引本身就是按照上述规则排好序的，所以直接从索引中提取数据，然后进行`回表`操作取出该索引中不包含的列就好了。

#### 使用联合索引进行排序注意事项

`ORDER BY`的子句后边的列的顺序也必须按照索引列的顺序给出

同理，`ORDER BY name`、`ORDER BY name, birthday`这种匹配索引左边的列的形式可以使用部分的`B+`树索引。当联合索引左边列的值为常量，也可以使用后边的列进行排序，比如这样：

```
SELECT * FROM person_info WHERE name = 'A' ORDER BY birthday, phone_number LIMIT 10;
```

#### 不可以使用索引进行排序的几种情况

##### ASC、DESC混用

>   ORDER BY子句后的列如果不加ASC或者DESC默认是按照ASC排序规则排序的，也就是升序排序的。

注意这里，name  升序查询，birthday 降序查询

```
SELECT * FROM person_info ORDER BY name, birthday DESC LIMIT 10;
```

这样操作累得一批~  重点是这样不能高效使用索引，而要采取更复杂的算法去从索引中取数据。所以规定，使用联合索引的各个排序列的排序顺序必须是一致的。

##### WHERE子句中出现非排序使用到的索引列

如果WHERE子句中出现了非排序使用到的索引列，那么排序依然是使用不到索引的，比方说这样：（country没有使用 索引）

```
SELECT * FROM person_info WHERE country = 'China' ORDER BY name LIMIT 10;
```

##### 排序列包含非同一个索引的列

```
SELECT * FROM person_info ORDER BY name, country LIMIT 10;
```

##### 排序列使用了复杂的表达式

```
SELECT * FROM person_info ORDER BY UPPER(name) LIMIT 10;
```

### 用于分组

```
SELECT name, birthday, phone_number, COUNT(*) FROM person_info GROUP BY name, birthday, phone_number
```

这个查询语句相当于做了3次分组操作：

-   所有`name`值相同的记录划分为一组。
-   将`birthday`值相同的记录放到一个小分组里
-   再将上一步中产生的小分组按照`phone_number`的值分成更小的分组

## 回表的代价

案例：

```
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

>   记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中，我们可以很快的把这些连着的记录从磁盘中读出来，这种读取方式我们也可以称为`顺序I/O`。
>
>   用户记录可能分布在不同的数据页中，这样读取完整的用户记录可能要访问更多的数据页，这种读取方式我们也可以称为`随机I/O`。

这个使用索引`idx_name_birthday_phone_number`的查询有这么两个特点：

-   会使用到两个`B+`树索引，一个二级索引（先），一个聚簇索引（后）。
-   访问二级索引使用`顺序I/O`，访问聚簇索引使用`随机I/O`。(一般情况下，顺序I/O比随机I/O的性能高很多)

需要回表的记录越多，使用二级索引的性能就越低，甚至让某些查询宁愿使用全表扫描也不使用`二级索引`。搜索的内容占比过高，导致回表程度高，吃力不太好了！

那什么时候采用全表扫描的方式，什么时候使用采用`二级索引 + 回表`的方式去执行查询呢？

这个就是传说中的查询优化器做的工作。后续了解

一般情况下，限制查询获取较少的记录数会让优化器更倾向于选择使用`二级索引 + 回表`的方式进行查询，因为回表的记录越少，性能提升就越高，比方说上边的查询可以改写成这样：

```
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' LIMIT 10;	
```

对于有排序需求的查询也可以使用 `LIMIT`，让优化器选择使用`二级索引 + 回表`的方式进行查询，提高性能。

### 覆盖索引

为了彻底告别`回表`操作带来的性能损耗，我们建议：最好在查询列表里只包含索引列

```
SELECT name, birthday, phone_number FROM person_info WHERE name > 'Asa' AND name < 'Barlow'
```

好在哪里？在通过`idx_name_birthday_phone_number`索引得到结果后就不必到`聚簇索引`中再查找记录的剩余列，也就是`country`列的值了，这样就省去了`回表`操作带来的性能损耗。

我们把这种只需要用到索引的查询方式称为`索引覆盖`。排序操作也优先使用`覆盖索引`的方式进行查询

```
SELECT name, birthday, phone_number  FROM person_info ORDER BY name, birthday, phone_number;
```

这个查询中没有`LIMIT`子句，但是采用了`覆盖索引`，所以查询优化器就会直接使用`idx_name_birthday_phone_number`索引进行排序而不需要回表操作了。

**我们很不鼓励用`*`号作为查询列表，最好把我们需要查询的列依次标明。**

## 如何挑选索引

建立索引时或者编写查询语句时就应该注意的一些事项

### 只为用于搜索、排序或分组的列创建索引

只为出现在`WHERE`子句中的列、连接子句中的连接列，或者出现在`ORDER BY`或`GROUP BY`子句中的列创建索引。

### 考虑列的基数

>   `列的基数`指的是某一列中不重复数据的个数

在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中。

结论：最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。

### 索引列的类型尽量小

在表示的整数范围允许的情况下，尽量让索引列使用较小的类型

结论：这个建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的`I/O`。

### 索引字符串值的前缀

只在`B+`树中存储字符串的前几个字符的编码，既节约空间，又减少了字符串的比较时间，还大概能解决排序的问题，何乐而不为，比方说我们在建表语句中只对`name`列的前10个字符进行索引可以这么写：

```
CREATE TABLE person_info(
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)
);    
```

`name(10)`就表示在建立的`B+`树索引中只保留记录的前`10`个字符的编码，这种只索引字符串值的前缀的策略是我们非常鼓励的，尤其是在字符串类型能存储的字符比较多的时候。

#### 索引列前缀对排序的影响

以下会比较尴尬

```
SELECT * FROM person_info ORDER BY name LIMIT 10;
```

无法对前十个字符相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式无法支持使用索引排序，只好乖乖的用文件排序喽。

### 让索引列在比较表达式中单独出现

如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。

### 主键插入顺序

如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽大忽小的话，这就比较麻烦了

可这个数据页已经满了啊，再插进来咋办呢？需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。

页面分裂和记录移位意味着什么？意味着：性能损耗！所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值依次递增，这样就不会发生这样的性能损耗了。

让主键具有`AUTO_INCREMENT`，让存储引擎自己为表生成主键，而不是我们手动插入

### 冗余和重复索引

定义的唯一索引和普通索引是重复的，这种情况要避免。

## 总结

本集内容总结如下：

1.  `B+`树索引在空间和时间上都有代价，所以没事儿别瞎建索引。
2.  `B+`树索引适用于下边这些情况：
    -   全值匹配
    -   匹配左边的列
    -   匹配范围值
    -   精确匹配某一列并范围匹配另外一列
    -   用于排序
    -   用于分组
3.  在使用索引时需要注意下边这些事项：
    -   只为用于搜索、排序或分组的列创建索引
    -   为列的基数大的列创建索引
    -   索引列的类型尽量小
    -   可以只对字符串值的前缀建立索引
    -   只有索引列在比较表达式中单独出现才可以适用索引
    -   为了尽可能少的让`聚簇索引`发生页面分裂和记录移位的情况，建议让主键拥有`AUTO_INCREMENT`属性。
    -   定位并删除表中的重复和冗余索引
    -   尽量使用`覆盖索引`进行查询，避免`回表`带来的性能损耗。