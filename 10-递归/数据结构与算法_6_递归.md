# 递归

[TOC]

## 餐前甜点

推荐注册返佣金的这个功能中，用户A推荐用户B来注册，用户B又推荐了用户C来注册。我们可以说，用户C的“最终推荐人”为用户A，用户B的“最终推荐人”也为用户A，而用户A没有“最终推荐人”。

一般来说，我们会通过数据库来记录这种推荐关系。在数据库表中，我们可以记录两行数据，其中actorid 表示用户id，referrer id 表示推荐人id。

基于这个背景，我的问题是，给定一个用户ID，如何查找这个用户的“最终推荐人”？

## 一，什么是递归？

1，递归 是一种 非常高效，简洁 的编码方式，一种应用非常广泛的算法，应用例子：DFS 深度优先算法，前中后序二叉树遍历等都是使用递归

2，方法或函数调用自身的方式称为 递归调用，调用称为 递，返回称为 归

3，基本上，所有的递归问题都可以用 递归公式 来表示，比如

```
f(n) = f(n-1) + 1; // 电影院 位置 问题 fn 表示需要求出的位置
f(n) = f(n-1) + f(n-2); // 爬楼梯问题，
f(n)=n*f(n-1);
```

## 二，为什么使用递归？递归的优缺点？

1，优点：递归代码表达力强，写起来非常简洁

2，缺点：空间复杂度高，有堆栈溢出的风险，存在重复计算，过多的函数调用会耗时较多等问题

## 三，什么样的问题可以用递归解决呢？

一个问题只要满足以下 3 个条件，就可以用递归解决；

1，问题的解 可以分解为几个 子问题。何为子问题？就是数据规模更小的问题。

2，问题与 子问题，除了数据规模不同，求解思路完全一样

3，存在递归终止条件。把问题分解为子问题，把子问题分解为子子问题，一层层分解下午，不能存在无限循环，这就需要有终止条件

## 四，如何实现递归？

### 1，递归代码 编写

写递归代码的关键就是 找到如何将大问题 分解为 小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。

### 2，递归代码 理解

对于递归代码，若试想了解清楚整个递和归的过程，实际上是进入了一个思维误区。

那该如何理解递归代码呢？如何一个问题A 可以分解为若干个子问题B、C、D，你可以假设子问题B、C、D已经解决。而且，你只需要思考问题A 与 问题B、C、D两层之间的关系即可，不需要一层层往下思考子问题和子子问题，子子问题和子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。

因此，理解递归代码，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。

## 五，递归常见问题及解决方案

1，警惕 —— 堆栈溢出：可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。

2，警惕 —— 重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算。

## 六，如何将递归改写成 非递归代码？

笼统的讲，所有的递归代码都可以改写成为迭代循环的非递归写法。

如何做？

抽象出递推公式，初始值和边界条件，然后用迭代循环实现。

## 七，答疑

解决方案：

```
long findRootReferrerId(long actorId) {
  Long referrerId = select referrer_id from [table] where actor_id = actorId;
  if (referrerId == null) return actorId;
  return findRootReferrerId(referrerId);
}
```

实际项目不能直接应用：

第一，如果递归很深，可能会有堆栈溢出的问题。

第二，如果数据库里存在脏数据，我们还需要处理由此产生的无限递归问题。比如demo环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果A的推荐人是B，B的推荐人是C，C的推荐人是A，这样就会发生死循环。

第一个问题，可以用限制递归深度来解决。第二个问题，也可以用限制递归深度来解决。不过，还有一个更高级的处理方法，就是自动检测A-B-C-A这种“环”的存在。暂时不细说

