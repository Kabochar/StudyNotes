# 字符串匹配

[TOC]

## BF 算法

BF算法中的BF是Brute Force的缩写，中文叫作暴力匹配算法，也叫朴素匹配算法。

什么是 主串？ 什么是 模式串？

比方说，我们在字符串A中查找字符串B，那字符串A就是主串，字符串B就是模式串。我们把主串的长度记作n，模式串的长度记作m。因为我们是在主串中查找模式串，所以n>m。

作为最简单、最暴力的字符串匹配算法，BF算法的思想可以用一句话来概括：我们在主串中，检查起始位置分别是0、1、2...n-m且长度为 m的 n-m+1 个子串，看有没有跟模式串匹配的。

![1553609337374](D:\Documents\笔记本\offer学习复习\BF-RK-BM-字符串匹配\1553609337374.png)

复杂度

最坏：O(n*m)。比如，主串是“aaaaa..…aaaaaa”（省略号表示有很多重复的字符a），模式串是“aaaaab”。

在实际的开发中，它却是一个比较常用的字符串匹配算法。

第一，实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把m个字符都比对一下。

所以，尽管理论上的最坏情况时间复杂度是o（n*m），但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。

第二，朴素字符串匹配算法思想简单，代码实现也非常简单。简单意味着不容易出错，如果有bug也容易暴露和修复。在工程中，在满足性能要求的前提下，简单是首选。这也是我们常说的 KISS（Keep it Simple and Stupid）设计原则。

所以，在实际的软件开发中，绝大部分情况下，朴素的字符串匹配算法就够用了。

## RK 算法

RK算法的全称叫Rabin-Karp 算法，是由它的两位发明者Rabin和Karp的名字来命名的。这个算法理解起来也不是很难。另一种说法，它其实就是刚刚讲的BF算法的升级版。

通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（这里先不考虑哈希冲突的问题，后面我们会讲到）。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。

![1553609623615](D:\Documents\笔记本\offer学习复习\BF-RK-BM-字符串匹配\1553609623615.png)

不过，通过哈希算法计算子串的哈希值的时候，我们需要遍历子串中的每个字符。尽管模式串与子串比较的效率提高了，但是，算法整体的效率并没有提高。有没有方法可以提高哈希算法计算子串哈希值的效率呢？

这就需要哈希算法设计的非常有技巧了。我们假设要匹配的字符串的字符集中只包含K个字符，我们可以用一个K进制数来表示一个子串，这个K进制数转化成十进制数，作为子串的哈希值。

![1553609686555](D:\Documents\笔记本\offer学习复习\BF-RK-BM-字符串匹配\1553609686555.png)

![1553609742697](D:\Documents\笔记本\offer学习复习\BF-RK-BM-字符串匹配\1553609742697.png)

复杂度分析

整个RK算法包含两部分，计算子串哈希值和模式串哈希值与子串哈希值之间的比较。

第一部分，我们前面也分析了，可以通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，所以这部分的时间复杂度是O（n）。

模式串哈希值与每个子串哈希值之间的比较的时间复杂度是O（1），总共需要比较 n-m+1个子串的哈希值，所以，这部分的时间复杂度也是O（n）。所以，RK算法整体的时间复杂度就是O（n）。

模式串很长，相应的主串中的子串也会很长，通过上面的哈希算法计算得到的哈希值就可能很大，如果超过了计算机中整型数据可以表示的范围，那该如何解决呢？

刚刚我们设计的哈希算法是没有散列冲突的，也就是说，一个字符串与一个二十六进制数一一对应，不同的字符串的哈希值肯定不一样。因为我们是基于进制来表示一个字符串的，你可以类比成十进制、十六进制来思考一下。实际上，我们为了能将哈希值落在整型数据范围内，可以牺牲一下，允许哈希冲突。

这个时候哈希算法该如何设计呢？

哈希算法的设计方法有很多，举一个例子说明一下。

假设字符串中只包含a~z这26个英文字母，那我们每个字母对应一个数字，比如a对应1，b对应2，以此类推，z对应26。我们可以把字符串中每个字母对应的数字相加，最后得到的和作为哈希值。这种哈希算法产生的哈希值的数据范围就相对要小很多了。

不过，你也应该发现，这种哈希算法的哈希冲突概率也是挺高的。当然，我只是举了一个最简单的设计方法，还有很多更加优化的方法，比如将每一个字母从小到大对应一个素数，而不是1，2，3...…这样的自然数，这样冲突的概率就会降低一些。

所以，哈希算法的冲突概率要相对控制得低一些，如果存在大量冲突，就会导致RK算法的时间复杂度退化，效率下降。

极端情况下，如果存在大量的冲突，每次都要再对比子串和模式串本身，那时间复杂度就会退化成O（n*m）。但也不要太悲观，一般情况下，冲突不会很多，RK算法的效率还是比BF算法高的。

## 总结

BF算法：最简单、粗暴的字符串匹配算法，它的实现思路是，拿模式串与主串中是所有子串匹配，看是否有能匹配的子串。

所以，时间复杂度也比较高，是O（n\*m），n、m表示主串和模式串的长度。不过，在实际的软件开发中，因为这种算法实现简单，对于处理小规模的字符串匹配很好用。

RK算法：借助哈希算法对BF算法进行改造，即对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间。

所以，理想情况下，RK算法的时间复杂度是O（n），跟BF算法相比，效率提高了很多。不过这样的效率取决于哈希算法的设计方法，如果存在冲突的情况下，时间复杂度可能会退化。极端情况下，哈希算法大量冲突，时间复杂度就退化为O（n*m）。

## 思考

我们今天讲的都是一维字符串的匹配方法，实际上，这两种算法都可以类比到二维空一间。假设有下面这样一个二维字符串矩阵（图中的主串），借助今天讲的处理思路，如何在其中查找另一个二维字符串矩阵（图中的模式串）呢？

![1553610089591](D:\Documents\笔记本\offer学习复习\BF-RK-BM-字符串匹配\1553610089591.png)

 以模式串矩阵的大小，去匹配主串矩阵，每个小矩阵可以构建成字符串，就能用 RK 算法做字符串匹配了。

如果主串的大小是 M * N，模式串大小为 m * n，则时间复杂度为 (M - m + 1) * (N - n + 1)。  

