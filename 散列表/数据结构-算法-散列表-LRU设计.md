# 散列表 - LRU 设计

[TOC]

## LRU 缓存淘汰算法

### 链表实现

我们需要维护一个按照访问时间从大到小有序排列的链表结构。因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，我们就直接将链表头部的结点删除。

当要缓存某个数据的时候，先在链表中查找这个数据。如果没有找到，则直接将数据放到链表的尾部；如果找到了，我们就把它移动到链表的尾部。因为查找数据需要遍历链表，所以单纯用链表实现的LRU缓存淘汰算法的时间复杂很高，是O（n）。

一个缓存（cache）系统主要包含下面这几个操作：

-   往缓存中 添加一个数据；
-   从缓存中 删除一个数据；
-   在缓存中 查找一个数据。

下面，通过散列表和链表结合实现。

![1553416887793](D:\Documents\笔记本\offer学习复习\散列表\1553416887793.png)

我们使用双向链表存储数据，链表中的每个结点处理存储数据（data）、前驱指针（prev）、后继指针（next）之外，还新增了一个特殊的字段hnext。

这个hnext有什么作用呢？hnext 指针是为了将结点串在散列表的拉链中

散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是刚刚我们提到的双向链表，另一个链是散列表中的拉链。前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中。

查找一个数据。通过散列表，查找数据的时间复杂度接近 O（1）。当找到数据之后，我们还需要将它移动到双向链表的尾部。

删除一个数据。我们需要找到数据所在的结点，然后将结点删除。链表是双向链表，双向链表可以通过前驱指针 O（1）时间复杂度获取前驱结点，所以，在双向链表中，删除结点只需要 O（1）

添加一个数据。先看这个数据是否已经在缓存中。如果已经在其中，需要将其移动到双向链表的尾部；如果不在其中，还要看缓存有没有满。如果满了，则将双向链表头部的结点删除，然后再将数据放到链表的尾部；如果没有满，就直接将数据放到链表的尾部。

## Java LinkedHashMap

按照访问时间排序的LinkedHashMap本身就是一个支持LRU缓存淘汰策略的缓存系统

总结：实际上，LinkedHashMap 是 通过 双向链表 和 散列表 这两种数据结构组合实现的。LinkedHashMap中的 “Linked” 实际上是指的是双向链表，并非指用链表法解决散列冲突。

## 更多

散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。

因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们将散列表和链表（或者跳表）结合在一起使用。

## 场景

1，今天讲的几个散列表和链表结合使用的例子里，我们用的都是双向链表。如果把双向链表改成单链表，还能否正常工作呢？为什么呢？

解决：  

以积分排序构建一个跳表，再以猎头 ID 构建一个散列表。

1）ID 在散列表中所以可以 O(1) 查找到这个猎头；
2）积分以跳表存储，跳表支持区间查询；
3）这点根据目前学习的知识暂时无法实现，老师文中也提到了。  

  在删除一个元素时，虽然能 O(1) 的找到目标结点，但是要删除该结点需要拿到前一个结点的指针，遍历到前一个结点复杂度会变为 O(N），所以用双链表实现比较合适。

（但其实硬要操作的话，单链表也是可以实现 O(1) 时间复杂度删除结点的）。  

2，假设猎聘网有10万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这10万个猎头ID和积分信息，让它能够支持这样几个操作：

-   根据猎头的ID快速查找、删除、更新这个猎头的积分信息；
-   查找积分在某个区间的猎头ID列表；
-   查找按照积分从小到大排名在第x位到第y位之间的猎头ID列表。

解决：

以积分排序构建一个跳表，再以猎头 ID 构建一个散列表。

1）ID 在散列表中所以可以 O(1) 查找到这个猎头；
2）积分以跳表存储，跳表支持区间查询；
3）这点根据目前学习的知识暂时无法实现，老师文中也提到了。  