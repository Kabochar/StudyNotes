# 数组

[TOC]


餐前甜点：为什么数组要从0开始编号，而不是从1开始的问题

## 一，数组如何实现随机访问

数组是一种线性数据机构，用连续的存储空间存储相同类型的数据

1，线性表：数组，链表，队列，栈；非线性表：树，图

2，连续的内存空间，相同的数据，大招：随机访问。

但对数组进行删除插入，保证数据的连续性，就需要做大量的数据迁移工作。

### A，数组如何根据下标随机访问数组元素？

前提：计算机会给每个内存单元分配一个地址，计算机可以通过地址来访问内存中的数据

计算机需要随机访问数组的某个元素时，可以通过以下的寻址公式

>   a[i]_address = base_address + i * data_type_size

data_type_size 表示数组中每个元素的大小

### B， 纠正数组的错误认识：数组的时间复杂度

数组的查找时间复杂度并不是O(1)，即便是排列好的数组，用二分查找，时间复杂度也是O（logn）

正确表述：数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)

## 二，低效的 插入 和 删除

1，插入操作

时间复杂度：最好O(1) ，最坏O(n)，平均O(n)

改进：数据 若无序，插入新的元素时，直接将第 K 位 的数据搬移到数组元素的最后，把新的元素直接放在第 K 个位置，此处复杂度为 O(1)

2，删除操作

时间复杂度：最好 O(1)，最坏 O(n)，平均O(n)

改进：先记录已经删除的的数据，每次的删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的储存空间的时候，我们再触发执行一次真正的删除操作。即 JVM 标记清除垃圾回收算法

## 三，警惕数组的访问越界问题

使用场景：限制在x86架构的小端模式

```c
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i <= 3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
Output:
hello word
hello word
hello word
hello word
...
```

为什么会出现无限打印？出现 数组访问越界

分析：在C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问。根据数组寻址公式，a[3]被定为到某块不属于数组的内存地址上，这刚好是 变量  i 的地址，那么 a[3] 相当于 i = 0，所以导致代码无限循环

《C陷阱与缺陷》：如果用来编译这段程序的编译器按照内存地址递减的方式给变量分配内存，那么内存中的i将会被置为0，则为死循环永远出不去。

形象解释：

内存分配是从后往前分配的。

例如，在Excel中从上往下拉4个格子，变量 i 会先被分配到第4个格子的内存，然后变量arr往上数分配3个格子的内存，但arr的数据是从分配3个格子的第一个格子从上往下存储数据的，当访问第3索引时，这时刚好访问到第4个格子变量i的内存。

## 四，容器，数组 如何选择

想比于数组，java 的 ArrayList 封装了数组的操作细节，并 支持 动态扩容。一旦超过存储容量，扩容时比较耗内存，因为涉及到内存申请和数据搬移

数组适合场景：

1，Java ArrayList 的使用涉及装箱拆箱，有一定的性能损耗，如果特别关注性能，进行底层开发，可以考虑数组

2，若 数组大小 已知，并且设计的数据操作非常简单，可以使用数组

3，在表示多维数组时，数组更加直观

## 五，解答开篇问题 —— 为什么数组要从0开始编号

1）	从偏移角度理解 a[0]，0为偏移量，如果从 1 计数，会多出 K-1。无疑增加cpu负担

为什么循环要写成 for(int i = 0;i<3;i++)  而不是 for(int i = 0 ;i<=2;i++) 

第一个直接就可以算出 3-0 = 3 有三个数据，而后者 2-0+1个数据，多出1个加法运算，很恼火

2）	也有一定的历史原因



## 拓展：

### 1，JVM标记清除算法

大多数主流虚拟鸡采用 可达性分析算法 来判断 对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象 标记为 存活。只有当标记工作完成后，清理工作才会开始。

不足：1，效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。2，空间问题。会产生不连续的内存空间碎片

### 2，二维数组内存寻址

对于 m * n 的数组，a \[ i ][ j ] (i < m，j < n)的地址为：

a \[ i ][ j ]_address = base_address + ( i * n + j) * data_type_size