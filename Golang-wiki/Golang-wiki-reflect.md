# Golang wiki reflect

目录

[TOC]

## 什么是反射

wiki 定义

在计算机科学中，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。

什么叫访问、检测和修改它本身状态或行为，它的本质是什么？

它的本质是程序在运行期探知对象的类型信息和内存结构。（汇编可以操作，高级语言不行）

## 为什么要用反射

使用场景：

-   编写一个函数，但是并不知道传给你的参数类型是什么，可能是没约定好，也可能是传入的类型很多，这些类型并不能统一表示。
-   需要根据某些条件决定调用哪个函数，比如根据用户的输入来决定。这时就需要对函数和函数的参数进行反射，在运行期间动态地执行函数。

不建议使用反射的理由：

-   经常是难以阅读的。
-   编译器能提前发现一些类型错误，但是对于反射代码是无能为力的。
-   反射对性能影响还是比较大的，比正常代码运行速度慢一到两个数量级。

## 反射是如何实现的

当向接口变量赋予一个实体类型的时候，接口会存储实体的类型信息，反射就是通过接口的类型信息实现的，反射建立在类型的基础上。

### types 和 interface

Go 语言中，每个变量都有一个静态类型，在编译阶段就确定了的；

### 反射的基本函数

reflect 包里定义了一个接口和一个结构体，即 `reflect.Type` 和 `reflect.Value`，它们提供很多函数来获取存储在接口里的类型信息。

`reflect.Type` 主要提供关于类型相关的信息，所以它和 `_type` 关联比较紧密；

 `reflect.Value` 则结合 `_type` 和 `data`两者，因此程序员可以获取甚至改变类型的值；

```
func TypeOf(i interface{}) Type
func ValueOf(i interface{}) Value
```

`TypeOf` 函数用来提取一个接口中值的类型信息。由于它的输入参数是一个空的 `interface{}`，调用此函数时，实参会先被转化为 `interface{}` 类型。

返回值 `reflect.Value` 表示 `interface{}` 里存储的实际变量，它能提供实际变量的各种信息。相关的方法常常是需要结合类型信息和值信息。

总结

`TypeOf()` 函数返回一个接口，这个接口定义了一系列方法，利用这些方法可以获取关于类型的所有信息； 

`ValueOf()` 函数返回一个结构体变量，包含类型信息以及实际值。

### 反射的三大定律

三大定律

-   反射将接口变量转换成反射对象 Type 和 Value；
-   反射可以通过反射对象 Value 还原成原先的接口变量；
-   反射可以用来修改一个变量的值，前提是这个值可以被修改。

KEY：解释第三句-> 如果想要操作原变量，反射变量 `Value` 必须要 hold 住原变量的地址才行。

## 反射相关函数的使用

### 相关函数使用

相关代码查阅原文

### 未导出成员

利用反射机制，对于结构体中未导出成员，可以读取，但不能修改其值。

注意，正常情况下，代码是不能读取结构体未导出成员的，但通过反射可以越过这层限制。另外，通过反射，结构体中可以被修改的成员只有是导出成员，也就是字段名的首字母是大写的。

>   一个可取地址的 reflect.Value 变量会记录一个结构体成员是否是未导出成员，如果是的话则拒绝修改操作。
>   CanAddr 不能说明一个变量是否可以被修改。
>   CanSet 则可以检查对应的 reflect.Value 是否可取地址并可被修改。

## 反射的实际应用

例如：IDE 中的代码自动补全功能、对象序列化（json 函数库）、fmt 相关函数的实现、ORM（全称是：Object Relational Mapping，对象关系映射）……

### json 序列化

```
func Marshal(v interface{}) ([]byte, error)
func Unmarshal(data []byte, v interface{}) error
```

对于序列化和反序列化函数，均需要知道参数的所有字段，包括字段类型和值，再调用相关的 get 函数或者 set 函数进行实际的操作。

### DeepEqual 的作用及原理

使用场景：判断两个变量的实际内容完全一致。例如：如何判断两个 slice 所有的元素完全相同；如何判断两个 map 的 key 和 value 完全相同等等。

```
func DeepEqual(x, y interface{}) bool
```

DeepEqual 的比较情形，总结如下：

| 类型                                  | 深度相等情形                                                 |
| :------------------------------------ | :----------------------------------------------------------- |
| Array                                 | 相同索引处的元素“深度”相等                                   |
| Struct                                | 相应字段，包含导出和不导出，“深度”相等                       |
| Func                                  | 只有两者都是 nil 时                                          |
| Interface                             | 两者存储的具体值“深度”相等                                   |
| Map                                   | 1、都为 nil；2、非空、长度相等，指向同一个 map 实体对象，或者相应的 key 指向的 value “深度”相等 |
| Pointer                               | 1、使用 == 比较的结果相等；2、指向的实体“深度”相等           |
| Slice                                 | 1、都为 nil；2、非空、长度相等，首元素指向同一个底层数组的相同元素，即 &x[0] == &y[0] 或者 相同索引处的元素“深度”相等 |
| numbers, bools, strings, and channels | 使用 == 比较的结果为真                                       |

源码如下：


```
func DeepEqual(x, y interface{}) bool {
	if x == nil || y == nil {
		return x == y
	}
	v1 := ValueOf(x)
	v2 := ValueOf(y)
	if v1.Type() != v2.Type() {
		return false
	}
	return deepValueEqual(v1, v2, make(map[visit]bool), 0)
}
```

## 总结

Go 作为一门静态语言，相比 Python 等动态语言，在编写过程中灵活性会受到一定的限制。但是通过接口加反射实现了类似于动态语言的能力：可以在程序运行时动态地捕获甚至改变类型的信息和值。

Go 语言的反射实现的基础是类型，或者说是 interface，当我们使用反射特性时，实际上用到的就是存储在 interface 变量中的和类型相关的信息，也就是常说的 `<type,value>` 对。

只有 interface 才有反射的说法。

反射在 reflect 包中实现，涉及到两个相关函数：

```
func TypeOf(i interface{}) Type
func ValueOf(i interface{}) Value
```

Type 是一个接口，定义了很多相关方法，用于获取类型信息。Value 则持有类型的具体值。Type、Value、Interface 三者间通过函数 TypeOf，ValueOf，Interface 进行相互转换。

反射三大定律：

-   反射将接口变量转换成反射对象 Type 和 Value；
-   反射可以通过反射对象 Value 还原成原先的接口变量；
-   反射可以用来修改一个变量的值，前提是这个值可以被修改。

## 参考

饶全成@深度解密Go语言之反射<https://mp.weixin.qq.com/s?__biz=MjM5MDUwNTQwMQ==&mid=2257483763&idx=1&sn=eeec4c937673573ab238a2b23e363e90&chksm=a5391725924e9e335389ed577d9ff39f100a658ad4d06a420b91290ed28e53c0342fd99ff3ad&scene=27#wechat_redirect&cpage=0>