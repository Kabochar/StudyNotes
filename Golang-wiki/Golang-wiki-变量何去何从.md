# Golang

目录

[TOC]

## 什么是逃逸分析？

在编译原理中，分析指针动态范围的方法称之为`逃逸分析`。通俗来讲，当一个对象的指针被多个方法或线程引用时，我们称这个指针发生了逃逸；

`逃逸分析`决定一个变量是分配在堆上还是分配在栈上；

## 为什么要逃逸分析？

真正地做到“按需分配”，一切简洁，高效；

通过逃逸分析，可以尽量把那些不需要分配到堆上的变量直接分配到栈上，堆上的变量少了，会减轻分配 堆内存 的开销，同时也会减少 gc 的压力，提高程序的运行速度；

## 逃逸分析是怎么完成的？

Go逃逸分析最基本的原则是：如果一个函数返回对一个变量的引用，那么它就会发生逃逸；

逃逸这件事谁来完成分析操作？

编译器做审判长！编译器它会分析代码的特征和代码生命周期；

Go中的变量只有在编译器可以**证明**在函数返回后不会再被引用的，才分配到栈上，其他情况下都是分配到堆上；

简单来说，编译器会根据变量是否被外部引用来决定是否逃逸：

>   1.  如果函数外部没有引用，则优先放到栈中；
>   2.  如果函数外部存在引用，则必定放到堆中；

针对第一条，可能放到堆上的情形：定义了一个很大的数组，需要申请的内存过大，超过了栈的存储能力。

## 逃逸分析实例

```
func foo() *int {
    t := 3
    return &t; // 关键，引用操作
}

func main() {
    x := foo()
    fmt.Println(*x)
}
```

检查命令，加`-l`是为了不让foo函数被内联：

```
go build -gcflags '-m -l' main.go
```

实例分析

```
# command-line-arguments
src/main.go:7:9: &t escapes to heap
src/main.go:6:7: moved to heap: t
src/main.go:12:14: *x escapes to heap
src/main.go:12:13: main ... argument does not escape
```

使用反汇编命令也可以看出变量是否发生逃逸：

```
go tool compile -S main.go
```

## 总结

-   堆上动态分配内存比栈上静态分配内存，开销大很多；
-   Go编译器会在编译期对考察变量的作用域，并作一系列检查，如果它的作用域在运行期间对编译器一直是可知的，那么就会分配到栈上；（别有一番 丈母娘 审视 女婿的滋味）
-   编译器会根据变量是否  被外部引用  来决定是否逃逸；
-   通过   `go build-gcflags'-m'`  命令来观察变量逃逸情况即可；
-   不要盲目使用变量的指针作为函数参数，虽然它会减少复制操作；
-   当参数为变量自身的时候，复制是在栈上完成的操作，开销远比变量逃逸后动态地在堆上分配内存少的多；
-   尽量写出少一些逃逸的代码，提升程序的运行效率；

## 参考

[饶全成@Golang之变量去哪儿](https://www.cnblogs.com/qcrao-2018/p/10453260.html)