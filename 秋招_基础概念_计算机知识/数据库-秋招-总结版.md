# SQL, 系统原理, MySQL, Redis

[TOC]

# SQL

## 视图

什么是视图？视图是一种基于数据表的一种**虚表**

-   视图是一种虚表
-   视图建立在已有表的基础上, 视图赖以建立的这些表称为基表
-   向视图提供数据内容的语句为 SELECT 语句,可以将视图理解为存储起来的 SELECT 语句
-   视图向用户提供基表数据的另一种表现形式
-   视图没有存储真正的数据，真正的数据还是存储在基表中
-   程序员虽然操作的是视图，但最终视图还会转成操作基表
-   一个基表可以有0个或多个视图

请求数据库信息时，他们想看到什么样的数据，我们就给他们什么样的数据...一方面就能够让他们只关注自己的数据，另一方面，我们也保证数据表一些保密的数据不会泄露出来...

视图就是基于查询的一种虚表，也就是说，视图可以将查询出来的数据进行封装。。。那么我们在使用的时候就会变得非常方便...

注意：使用视图可以让我们专注与逻辑，但不提高查询效率

## 分组查询，连接查询，连接与子查询

略

## Drop，Delete，Truncate

>   数据操纵语言DML：主要形式，INSERT，UPDATE，DELETE
>
>   数据定义语言DDL：用来创建数据库中的各种对象，CREATE TABLE，VIEW，INDEX，SYN，CLUSTER

### Drop Table

-   属于 DDL
-   不可回滚
-   不可带where
-   表内容和结构删除
-   删除速度快

### Delete Table

-   属于 DDL
-   不可回滚
-   不可带where
-   表内容删除-删除记录
-   删除速度快

### Truncate Table

-   属于 DML
-   可回滚
-   可带 where
-   表结构在，表内容要看where执行的情况
-   删除速度慢，需要逐行删除

### 三者取舍

-   不再需要一张表的时候，用 drop
-   想删除部分数据行时候，用 delete，并且带上where子句
-   保留表而删除所有数据的时候用 truncate

# 系统原理

## ACID

什么是事务？答：一个Session中所进行所有的操作，要么同时成功，要么同时失败

事务的作用？处理数据量大，复杂度高的数据

ACID — 数据库事务正确执行的 **4** 个基本要素：原子性，一致性，隔离性，持久性

原子性：一干到底。错了重头再来呗；

一致性：做事情前后要一致完整；

隔离性：并发下，我干我的，你干你的，井水不犯河水；

持久性：钱到我荷包里就是我的；

为什么必需要具有这四种特性？答：否则，在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易；

## 隔离级别

数据库定义了4个隔离级别：

Serializable【可避免脏读，不可重复读，虚读】-->  TRANSACTION_SERIALIZABLE

Repeatable read【可避免脏读，不可重复读】-->  TRANSACTION_REPEATABLE_READ

Read committed【可避免脏读】-->  TRANSACTION_READ_COMMITTED

Read uncommitted【级别最低，什么都避免不了】-->  TRANSACTION_READ_UNCOMMITTED

脏读：事情还没完全完成就发生后续情况；

不可重复读：一个事务可以看到其他事务所做的修改；

虚读(幻读)：一个事务内读取到了别的事务插入的数据，导致前后读取不一致

总结：脏读是不可容忍的，不可重复读和虚读在一定的情况下是可以的【做统计的肯定就不行】。

## 乐观锁 & 悲观锁

乐观锁和悲观锁是什么？

答，并发控制主要采用的技术手段。处理场景：确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性

-   悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作 
    -   在查询完数据的时候就把事务锁起来，直到提交事务
    -   实现方式：使用数据库中的锁机制
-   乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 
    -   在修改数据的时候把事务锁起来，通过version的方式来进行锁定
    -   实现方式：使用version版本或者时间戳

## MVVC

什么是MVVC？ MVVC是用于数据库提供并发访问控制的并发控制技术。

为什么出现？数据库的并发控制机制有很多，最为常见的就是锁机制。锁机制一般会给竞争资源加锁，阻塞读或者写操作来解决事务之间的竞争条件，最终保证事务的可串行化。MVVC则引入了另外一种并发控制，它让读写操作互不阻塞，每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回，由此解决了事务的竞争条件。

## SQL & NoSQL

### 关系型数据库 SQL

#### 1，行存储结构

关系型数据库是行存储结构。当你只想拿一行里面的几列时，从硬盘读取到内存中的数据也会是整行的数据，当数据量很大的时候，IO就吃不消了。

#### 2，强结构

关系型数据库的表结构有很强的约束，必须按照指定格式存储，缺乏灵活性。

#### 3，没内存型数据库快

拖拉机 比 飞机 谁跑得快，emmmm

#### 4，全文检索能力弱

一般关系型数据库只能like全表扫描，性能很差。虽然像mysql也有全文索引。

### 非关系型数据库 NoSQL

#### 1，K-V类

-   全称Key-Value。
-   它是存储在内存中的，所以速度快常用来作为缓存服务器。 而且因为它的结构导致有些操作比关系型数据库简单。
-   它ACID事务只支持I和C也就是隔离性和一致性，不支持原子性和持久性。所以在一些对事务要求的情况下就不适合了。
-   代表数据库就是redis。redis的value还分了很多结构，例如:list、set、sorted set、hash、string等；

#### 2，文档型

-   这个类型它的结构没有约束，可以存储任意结构；
-   文档型存储的数据格式一般都是Json，Json里面的字段我任意填，无拘无束。
-   代表的数据库有MongoDB；

#### 3，列式存储型

-   按列存储，因为列的存储是不连续的，所以磁盘读取效率比行低。这点比 按行存储的数据库性能上要差

-   按列的话就有可能有些列成功，有些列失败；

-   节省I/O就采用按列存储，这样每次只需要拿想要的列进行统计；

-   代表的数据库是HBase，多用于离线的大数据分析和统计；

    >   为什么离线？写的操作可能会有问题，并且整行读的效率低

#### 4，全文检索型

-   全文检索引擎采用倒排索引，也就是每个单词都是索引，建立单词到文档的索引；

-   代表的有Elasticsearch，分布式文档存储方式。

    >   使用方式就是我们从关系数据库中导出数据，转换成Json格式然后将其输入Elasticsearch中建立索引然后使用。

## 封锁

略

## 范式

略

# MySQL

## B+Tree

### B+Tree & B-Tree

B-Tree

B-Tree中，每个节点中不仅包含数据的key值，还有data值，因为每个节点的存储空间有限制，如果data数据较大时将会导致每个节点能存储的key的数量很小，当data量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。

B+Tree

 B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

特性：

-   所有关键字都出现在叶子结点的链表中，且链表中的关键字恰好是有序的； 
-   不可能在非叶子结点命中；
-   非叶子结点相当于是叶子结点的索引，叶子结点相当于是存储数据的数据层； 
-   B+Tree上有两个头指针，一个指向根节点，另一个指向最小key的叶子节点，所有叶子节点之间是一种链式环结构

## 索引以及优化

### 索引基础

#### 1，BTree索引

innodb 只显式支持B树索引，对于频繁访问的表，innodb会透明建立自适应hash索引， 即在B树索引基础上建立hash索引，可以显著提高查找效率，对于客户端是透明的，不可控制的，隐式的。

#### 2，Hash索引特性

只支持包括 “=” "in "在内的等值查询，不支持范围，前缀匹配查询

Hash索引是通过hash函数将，**键值直接映射为物理存储地址**，使时间复杂度降低到O(1)，本身存储是无序的，所以不能通过hash索引避免排序

#### 3，Mysql聚簇索引

Mysql为什么要采用B+树索引呢？

1，遍历方便。B+树可以将键值保存在（线性表【数组或链表】）中，遍历线性表比索引树要快，因为保存在线性表中数据存储更加密集，相应的减少了寻到次数。B Tree数据是分散的，导致更多的 随机 IO，需要额外的磁道寻道操作。

2，插入更新索引树时可以避免移动节点；

3，遍历任何节点的时间复杂度相同，即访问路径总是从根节点到叶子节点。这个相对 B Tree时间略长

4，范围查找方便。其数据是按照大小排列的。例如，A, B 范围，B+Tree 可以直接找到A,B对应的线性表中节点，只需要返回区间的所有节点 即为目标结果。而B-树则稍显麻烦需要继续遍历索引树。

### 索引常见优化方法

#### 不能使用索引,不建议使用索引等常见误区

1，数据类型为Text，Blob等大对象不能建立索引，也不适合建立索引，另外字段太长的字段不适合建立索引。

需要扫描的时间过长

2，查询表达式索引项上有函数，mysql将无法使用相应索引

3，一次查询（简单查询，子查询不算）只能使用一个索引；

4，where后的查询表达式顺序不能决定使用哪个索引，使用哪个索引由相应索引项的选择率决定，最终判定标准是：扫描最少的行.使用索引过滤尽可能多的行。

5，修改过于频繁的列使用索引要慎重。

可能出现问题：过于频繁的更新对于索引负担太重，磁盘负载过重，另外更新操作可能会锁住相关记录，有死锁和事务超时可能。

解决：可以通过分区分表或者缓存解决

6，选择率低的列不适合建立索引

7，Mysql中对于唯一性检查即声明unique的列，自动建立唯一性索引，不需要再额外建立索引

8，不应该对where中每一个查询条件都建立上索引。简化索引设计，同时利用联合索引满足多项条件的查询；

9，Order By ,Group By 可以利用索引避免排序。

优先根据where 查询使用索引，然后根据where中使用的索引再决定，order by,group by是否可以 使用到索引

10，当数据量达到千万级别以上，索引本身就很大，带来一系列后续问题。

当并发量不大情况下，建立分区表可有效提高速度，因为分区表的索引结构是互相独立的，可单独装入内存，减少磁盘访问。

11，更新删除时指定索引列；

>   幻读是指对一个范围的数据进行修改带来的读不一致，不光插入删除，更新也会导致幻读
>
>   mysql 解决幻读有两种方案：
>
>   1，对于查询select操作只是针对本事务开启时刻的“镜像”查询；
>
>   2，更新删除【包括 select ………… for update 】等写操作涉及到范围更新时，如果查询条件where中存在索引，即锁住索引树的相关键值段

#### 索引设计的几个“原则”

1，索引的设计应该与业务需求息息相关，应随时根据业务合理取舍。

2，索引设计应该优先照顾查询最为频繁，或业务优先级高，与用户相关的查询；

3，使用短索引,索引长度不宜过大

利用B Tree的特性使用最左匹配查找高效利用索引第一列、对选择率高的列索引、使用覆盖索引避免回表查询 4.及时删除不再使用的索引

#### 联合索引的顺序问题

1，联合索引设计时，索引顺序是很重要的。

2，使用部分前缀索引键，按照联合索引声明顺序查询。

3，前缀匹配，与范围匹配。 

 BTree索引可以使用前缀匹配，例如 where A like "xxx%" ,使用前缀索引后，就不能使用前缀列的后续索引列。

4，group by,order by 本质是对where查询出的结果集进行排序操作，当待排序列匹配 where 中索引顺序时才可避免排序，直接通过索引即可返回有序结果集

5，limit 分页查询，分页时不同页会有出现重复数据的风险。

-   limit 使用时必须排序否则可能出现不同页返回重复数据的风险。
-   当分页没有特别指定的列时，指定主键排序即可，另外不需要在联合索引最后一列添加主键，因为它本身包含主键 【非聚簇索引不存储完整记录，通过访问主键索引找到完整记录 】

### SQL优化

#### 1，选择最优效率的表名顺序

数据库的解析器按照：**从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表将被最先处理**

在FROM子句中包含多个表的情况下：**选择记录条数最少的表放在最后**

如果有3个以上的表连接查询：**被其他表所引用的表放在最后**

案例：

查询员工的编号，姓名，工资，工资等级，部门名

解析：emp表被引用得最多，记录数也是最多，因此放在form字句的最后面

```
select emp.empno,emp.ename,emp.sal,salgrade.grade,dept.dname
from salgrade,dept,emp
where (emp.deptno = dept.deptno) and (emp.sal between salgrade.losal and salgrade.hisal)
```

#### 2，WHERE子句中的连接顺序

数据库采用：自**右而左的顺序解析WHERE子句**

**表之间的连接必须写在其他WHERE条件之左**,那些**可以过滤掉最大数量记录的条件必须写在WHERE子句的之右**。

案例：薪水

**emp.sal可以过滤多条记录，写在WHERE字句的最右边**

```
select emp.empno,emp.ename,emp.sal,dept.dname
from dept,emp
where (emp.deptno = dept.deptno) and (emp.sal > 1500) 
```

#### 3，SELECT子句中避免使用*号

“*”号是可以获取表中全部的字段数据的，但这会消耗很多时间

#### 4，用TRUNCATE替代DELETE

TRUNCATE，保留结构，删除内容

DELETE，一条条删除内容

#### 5，多使用内部函数提高SQL效率

比如，concat() ，链接字符

#### 6，使用表或列的别名

简短的别名可以稍微提高一些 SQL 的性能，扫描的内容少了

7，多使用commit

commit 会释放回滚点 ？？？？

#### 8，善用索引

索引的存在就是为了提高查询效率，当表的记录量大的时候就可以使用了。

#### 9，SQL写大写

推荐使用大写来写关键词

#### 10，避免再索引列上使用 NOT

Oracle在遇到 NOT 后，会停止目前的工作，转而执行全表扫描

#### 11，避免在索引列上使用计算

WHERE子句中，**如果索引列是函数的一部分，优化器将不使用索引而使用全表扫描，这样会变得变慢**

#### 12，用 `>=` 替代 `>`

差异在哪里？》符号会立马定位到前一位上，而 》= 直接定位到目标位置上

#### 13，总是使用索引的第一个列

注意，从第一个列，一直往后延申，才能使用到索引，不引用索引的第一个列时，优化器使用了全表扫描而忽略了索引；

### 数据库结构优化(仅作了解)

-   1）范式优化： 比如消除冗余（节省空间。。）
-   2）反范式优化：比如适当加冗余等（减少join）
-   3）拆分表： 垂直拆分和水平拆分

### 服务器硬件优化

花钱加机器吧— —

## InnoDB & MyISAM

版本历史：在 MySQL 5.1 及之前的版本中，MyISAM 是默认的存储引擎，而在 MySQL 5.5 版本以后，默认使用 InnoDB 存储引擎。

>   什么是行锁and表锁？Mysql的行锁和表锁（ 锁是计算机协调多个进程或纯线程并发访问某一资源的机制）
>
>   **表级锁：** 每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；
>
>   **行级锁：** 每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；

两者差异：

MyISAM

-    不支持行级锁，即是，MyISAM 会对整张表加锁，而不是针对行。读取时对需要读到的所有表加锁，写入时则对表加排他锁；
-   MyISAM 不支持事务和外键；
-   对于不会进行修改的表，支持 压缩表，存储空间较小；
-   MyISAM 在筛选大量数据时非常快；
-   不支持崩溃后的安全恢复；
-   支持延迟更新索引，极大地提升了写入性能；
-   在表有读取查询的同时，支持往表中插入新纪录；
-   支持BLOB和TEXT的前500个字符索引，支持全文索引

InnoDB

-   事务型引擎，当事务异常提交时，会被回滚；
-   InnoDB 支持行锁，采用MVCC（一种并发控制的方法）来支持高并发，有可能死锁；
-   InnoDB 需要更多存储空间，会在内存中建立其专用的缓冲池用于高速缓冲数据和索引；
-   InnoDB 支持自动奔溃恢复特性；
-   不支持全文索引

主要差异：

| 方面         | MyISAM | InnoDB |
| ------------ | ------ | ------ |
| 事务         | 不支持 | 支持   |
| 外键         | 不支持 | 支持   |
| 行级锁       | 不支持 | 支持   |
| 自动奔溃恢复 | 不支持 | 支持   |

适用场景：

Innodb引擎适用场景：

-   需要事务的操作；
-   更新数据需要是哦那个行级锁；
-   大数据量读写；
-   大型互联网应用；

MyISAM引擎适用场景：

-   不需要事务的操作；
-   插入、更新少，读取频繁；
-   频繁的统计计算；

如何选择 InnoDB & MyISAM？

答，优先选择 InnoDB 存储引擎，并且尽量不要将 InnoDB 与 MyISAM 混合使用。

# Redis

<https://github.com/pumkinpie/StudyNotes/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93_SQL_MySQL_Redis/Redis-%E5%9F%BA%E7%A1%80-%E6%80%BB%E8%A7%88.md>



# 参考

深入理解mysql 索引特性(面试高频,屡试不爽的mysql索引总结) 

<https://juejin.im/post/5d4e7f496fb9a06afe128655#heading-2>

数据库常见面试题(开发者篇)

<https://juejin.im/post/5a9ca0d6518825555c1d1acd#heading-15>

MySQL常见的两种存储引擎：MyISAM与InnoDB的爱恨情仇

<https://juejin.im/post/5b1685bef265da6e5c3c1c34>

MySQL存储引擎Innodb和MyISAM对比总

<https://juejin.im/post/5a7693875188257a814ce5a3>

NoSQL 还是 SQL ？这一篇讲清楚

<https://juejin.im/post/5b7e6fd251882542aa1b35f9>

面试官：说说你对NoSQL的了解，为什么要有NoSQL

<https://juejin.im/post/5cbc13b06fb9a0685a3f014a#heading-5>