# 链表

[TOC]



## 使用场景

缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。

## 常见的缓存淘汰策略

先进先出策略 FIFO（First In，First Out）、最少使用策略LFU（Least Frequently Used）、最近最少使用策略LRU（Least Recently Used）。

## 链表类型

底层存储结构上看：链表通过 指针 将一组 零散的内存块 串联 在一起。

结点：内存块。

后继指针 next ：记录下个结点地址的指针。

头结点 ：第一个结点，用来记录链表的 基地址，可以遍历得到整条链表；

尾结点 ：最后一个结点，特殊是，指针不是指向下一个结点，而是指向一个 空地址 NULL，表示这是链表上最后一个结点。

### 单链表

单向连接，next 指针记录下一个节点的地址，尾结点 指向 null，表示链表结束。

为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要 记录链上的下一个结点的地址。

时间复杂度

-   space：O(n)
-   pre 添加 prepend：O(1)
-   last 添加 append：O(1)
-   查找 lookup：O(n)
-   插入 insert：O(1)
-   删除 delete：O(1)

## 循环链表

跟单链表唯一的区别：尾结点上。

单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是 指向链表的头结点。它像一个环一样首尾相连，所以叫作 “循环” 链表。

使用场景：当要处理的数据具有环型结构特点时，适合采用循环链表。

## 双向链表

它支持两个方向，每个结点不止有一个后继指针next 指向后面的结点，还有一个前驱指针prev指向前面的结点。

**利弊：**

1，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。

2，两个指针比较浪存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。

3，从结构上来看，双向链表可以支持O（1）时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。

## 删除操作场景观察

在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：

-   删除结点中“值等于某个给定值”的结点；
-   删除给定指针指向的结点。	

**其一：**

不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过指针操作将其删除。

分析：单纯的删除操作时间复杂度是O（1），但遍历查找的时间是主要的耗时点，对应的时间复杂度为O（n）。

**其二：**

删除某个结点q需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到p->next=q，说明p是q的前驱结点。

但，双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。

分析：单链表删除操作需要O（n）的时间复杂度，而双向链表只需要在O（1）的时间复杂度内就搞定了！

**拓展：**

对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。

因为，我们可以记录上次查找的位置p，每次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。

**场景需求分析总结：**

对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；

消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。

LinkedHashMap 实现原理：同样使用 双向链表

## 链表 VS 数组

| 时间复杂度 | 数组 | 链表 |
| ---------- | ---- | ---- |
| 插入，删除 | O(n) | O(1) |
| 随机访问   | O(1) | O(n) |

**大小上：**

数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）"。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。

**后期维护上：**

如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java 语言，就有可能会导致频繁的GC（Garbage Collection，垃圾回收）。

## 代码编写注意事项

1，理解指针的或引用的含义

指针：存储 内存地址的一个变量。它可以通过 内存地址寻找 目标变量。

2，警惕指针丢失 和 内存泄漏

注意链表的操作的顺序，不要丢失链表。

删除节点的时候，一定记得释放内存空间。

3，利用 哨兵 简化操作

哨兵节点不存储数据，只是为了方便后续的链表操作。

不管任何时间，链表的 head 都指向哨兵节点。

4，留意 边界条件处理

-   如果链表为空时，代码是否能正常工作？
-   如果链表只包含一个结点时，代码是否能正常工作？
-   如果链表只包含两个结点时，代码是否能正常工作？
-   代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

5，举例画图，辅助思考

6，多写多练

## Leetcode

对应编号：206，141，21，19，876。



