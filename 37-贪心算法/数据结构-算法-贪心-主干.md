# 贪心算法

[TOC]

## 基础

同一场景下，拥有数量最多，但是操作次数少。

解决问题步骤

1，针对一组数据，我们定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。

2，我们尝试看下这个问题是否可以用贪心算法解决：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据

3，我们举几个例子看下贪心算法产生的结果是否是最优的。

实际上，用贪心算法解决问题的思路，并不总能给出最优解。

## 实战分析

1，分糖果

我们有m个糖果和n个孩子。我们现在要把糖果分给这些孩子吃，但是糖果少，孩子多（m<n），所以糖果只能分配给一部分孩子。

每个糖果的大小不等，这m个糖果的大小分别是s1，s2，s3，...…，sm。除此之外，每个孩子对糖果大小的需求也是不一样的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足。假设这n个孩子对糖果大小的需求分别是g1，g2，93，..…，gn。

我的问题是，如何分配糖果，能尽可能满足最多数量的孩子？

先满足对糖果数量要求小的孩子，再满足要求高的孩子，从而达到满足孩子数量最多的情况。

2，钱币找零

这个问题在我们的日常生活中更加普遍。假设我们有1元、2元、5元、10元、20元、50元、100元这些面额的纸币，它们的张数分别是c1、c2、c5、c10、c20、c50、c100。我们现在要用这些钱来支付K元，最少要用多少张纸币呢？

条件：最少数量的纸币。

先使用 面额大的纸币，再使用小的，类推下去

3，区间覆盖

假设我们有n个区间，区间的起始端点和结束端点分别是[11，r1]，[12，r2]，[13，r3]，..…，[In，rn]。我们从这n个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？

条件：选出最多区间

我们假设这n个区间中最左端点是lmin，最右端点是rmax。这个问题就相当于，我们选择几个不相交的区间，从左到右将[Imin，rmax]覆盖上。我们按照起始端点从小到大的顺序对这n个区间排序。
我们每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。

## 场景

如何用贪心算法实现霍夫曼编码？假设我有一个包含1000个字符的文件，每个字符占1个byte（1byte=8bits），口存储这1000个字符就一共需要8000bits，那有没有更加节省空间的存储方式呢？

霍夫曼编码是一种十分有效的编码方法，广泛用于数据压缩中，其压缩率通常在20%~90%之间。霍夫曼编码不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率，根据频率的不同，选择不同长度的编码。

如何给不同频率的字符选择不同长度的编码呢？根据贪心的思想，我们可以把出现频率比较多的字符，用稍微短一些的编码；出现频率比较少的字符，用稍微长一些的编码。

![1553701407252](D:\Documents\笔记本\offer学习复习\贪心算法\1553701407252.png)

假设这6个字符出现的频率从高到低依次是a、b、c、d、e、f。我们把它们编码下面这个样子，任何一个字符的编码都不是另一个的前缀，在解压缩的时候，我们每次会读取尽可能长的可解压的二进制串，所以在解压缩的时候也不会歧义。经过这种编码压缩之后，这1000个字符只需要2100bits就可以了。

![1553701429267](D:\Documents\笔记本\offer学习复习\贪心算法\1553701429267.png)

如何根据字符出现频率的不同，给不同的字符进行不同长度的编码呢？

我们把每个字符看作一个节点，并且辅带着把频率放到优先级队列中。我们从队列中取出频率最小的两个节点A、B，然后新建一个节点C，把频率设置为两个节点的频率之和，并把这个新节点C作为节点A、B的父节点。最后再把C节点放入到优先级队列中。重复这个过程，直到队列中没有数据。

![1553701464496](D:\Documents\笔记本\offer学习复习\贪心算法\1553701464496.png)

现在，我们给每一条边加上画一个权值，指向左子节点的边我们统统标记为0，指向右子节点的边，我们统统标记为1，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。

![1553701514420](D:\Documents\笔记本\offer学习复习\贪心算法\1553701514420.png)

## 总结

实际上，贪心算法适用的场景比较有限。这种算法思想更多的是指导设计基础算法。比如最小生成树算法、单源最短路径算法，这些算法都用到了贪心算法。

不要刻意去记忆贪心算法的原理，多练习才是最有效的学习方法。

贪心算法的最难的一块是如何将要解决的问题抽象成贪心算法模型，只要这一步搞定之后，贪心算法的编码一般都很简单。

很多时候，我们只需要多举几个例子，看一下贪心算法的解决方案是否真的能得到最优解就可以了。

## 思考

1，在一个非负整数a中，我们希望从中移除k个数字，让剩下的数字值最小，如何选择移除哪k个数字呢？

由最高位开始，比较低一位数字，如高位大，移除，若高位小，则向右移一位继续比较两个数字，直到高位大于低位则移除，循环k次，如：
4556847594546移除5位-》455647594546-》45547594546-》4547594546-》4447594546-》444594546

2，假设有n个人等待被服务，但是服务窗口只有一个，每个人需要被服务的时间长度是不同的，如何安排被服务的先后顺序，才能让这n个人总的等待时间最短？

由等待时间最短的开始服务

3，找零问题不能用贪婪算法，即使有面值为一元的币值也不行：考虑币值为100，99和1的币种，每种各一百张，找396元。
动态规划可求出四张99元，但贪心算法解出需三张一百和96张一元。