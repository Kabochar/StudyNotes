# B+树索引 (精简版)

## 没有索引的查找

### 在一个页中的查找

记录比较少，所有的记录都可以被存放到一个页中

-   以主键为搜索条件

    在`页目录`中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

-   以其他列作为搜索条件

    只能从`最小记录`开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。(非常耗时)

### 在很多页中查找

1.  定位到记录所在的页。
2.  从所在的页内中查找相应的记录。

只能从第一个页沿着双向链表一直往下找，在每一个页中根据 页的查找方式查找方式去查找指定的记录。

## 索引

将记录放到页里边的示意图：

![1565345770524](pics\1565345770524.png)

### 一个简单的索引方案

快速定位记录所在的数据页而建立一个别的目录，建这个目录必须完成：

-   下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。

    如果插入删除后主键值不满足条件，会通过移动的操作来始终保证这个状态一直成立。这个过程我们也可以称为`页分裂`。

-   给所有的页建立一个目录项。（方便检索）

    由于数据页的编号可能并不是连续的，效果如下

![1565346268111](pics\1565346268111.png)

因为这些`16KB`的页在物理存储上可能并不挨着，所以如果想从多页中根据主键值快速定位某些记录所在的页，需要给它们做个目录，每个页对应一个目录项，每个目录项包括下边两个部分：（这个`目录`有一个别名，称为`索引`）

-   页的用户记录中最小的主键值，我们用`key`来表示。
-   页号，我们用`page_no`表示。

完成效果如下：

![1565346356849](pics\1565346356849.png)

### InnoDB中的索引方案

大佬们 复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为`目录项记录`。

记录头信息里的`record_type`属性，它的各个取值代表的意思如下：

-   `0`：普通的用户记录
-   `1`：目录项记录
-   `2`：最小记录
-   `3`：最大记录

完成以后效果如下：

![1565346459733](pics\1565346459733.png)

强调一遍`目录项记录`和普通的`用户记录`的不同点：

-   `目录项记录`的`record_type`值是1，而普通用户记录的`record_type`值是0。
-   `目录项记录`只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有`InnoDB`自己添加的隐藏列。
-   记录头信息中 min_rec_mask`属性，只有在存储`目录项记录`的页中的主键值最小的`目录项记录`的`min_rec_mask`值为`1`，其他别的记录的`min_rec_mask`值都是`0`。

拓展，再分配一个新的存储`目录项记录`的页：

![1565346670539](pics\1565346670539.png)

升级：为这些存储`目录项记录`的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，效果如下：

![1565346754262](pics\1565346754262.png)

形象，上头是树根，下头是树叶！其实这是一种组织数据的形式，或者说是一种数据结构，它的名称是`B+`树。

![1565346797690](pics\1565346797690.png)

注意到，实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为`叶子节点`或`叶节点`，其余用来存放`目录项`的节点称为`非叶子节点`或者`内节点`，其中`B+`树最上边的那个节点也称为`根节点`。

>   规定最下边的那层，也就是存放我们用户记录的那层为第`0`层，之后依次往上加。

#### 聚簇索引

`B+`树本身就是一个目录，或者说本身就是一个索引。它有两个特点：

1.  使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：

    -   页内的记录是按照  主键的大小顺序排成一个单向链表。
    -   各个存放用户记录的页也是根据页中用户记录的  主键大小顺序排成一个双向链表。
    -   存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的  主键大小顺序排成一个双向链表。

2.  `B+`树的叶子节点存储的是完整的用户记录。

    所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

具有这两种特性的`B+`树称为`聚簇索引`，所有完整的用户记录都存放在这个`聚簇索引`的叶子节点处。

在`InnoDB`存储引擎中，`聚簇索引`就是数据的存储方式（所有的用户记录都存储在了`叶子节点`），也就是所谓的索引即数据，数据即索引。

`聚簇索引`只能在搜索条件是主键值时才能发挥作用，因为`B+`树中的数据都是按照主键进行排序的。

#### 二级索引

想以别的列作为搜索条件该咋办呢？难道只能从头到尾沿着链表依次遍历记录么？

多建几棵`B+`树，不同的`B+`树中的数据采用不同的排序规则。

例如：

![1565347186162](pics\1565347186162.png)

如果我们想根据`c2`列的值查找到完整的用户记录的话，仍然需要到`聚簇索引`中再查一遍，这个过程也被称为`回表`。也就是根据`c2`列的值查询一条完整的用户记录需要使用到`2`棵`B+`树！！！

为什么我们还需要一次`回表`操作呢？直接把完整的用户记录放到`叶子节点`不就好了么？你说的对，如果把完整的用户记录放到`叶子节点`是可以不用`回表`，但是太占地方了呀～相当于每建立一棵`B+`树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。

#### 联合索引

可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引

![1565347280540](pics\1565347280540.png)

### InnoDB的B+树索引的注意事项

#### 根页面万年不动窝

为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上`B+`树的形成过程是这样的：

-   每当为某个表创建一个`B+`树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个`根节点`页面。最开始表中没有数据的时候，每个`B+`树索引对应的`根节点`中既没有用户记录，也没有目录项记录。
-   随后向表中插入用户记录时，先把用户记录存储到这个`根节点`中。
-   当`根节点`中的可用空间用完时继续插入记录，此时会将`根节点`中的所有记录复制到一个新分配的页，比如`页a`中，然后对这个新页进行`页分裂`的操作，得到另一个新页，比如`页b`。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到`页a`或者`页b`中，而`根节点`便升级为存储目录项记录的页。

非常注意：一个B+树索引的根节点自诞生之日起，便不会再移动。

#### 内节点中目录项记录的唯一性

#### 一个页面最少存储2条记录

B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度杠杠的！

### MyISAM中的索引方案简单介绍

`MyISAM`的索引方案虽然也使用树形结构，但是却将索引和数据分开存储：

-   将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为`数据文件`。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过行号而快速访问到一条记录。

    由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。

-   使用`MyISAM`存储引擎的表会把索引信息另外存储到一个称为`索引文件`的另一个文件中。

    也就是先通过索引找到对应的行号，再通过行号去找对应的记录！

    `InnoDB`存储引擎中，我们只需要根据主键值对`聚簇索引`进行一次查找就能找到对应的记录，而在`MyISAM`中却需要进行一次`回表`操作，意味着`MyISAM`中建立的索引相当于全部都是`二级索引`！

-   如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和`InnoDB`中的索引差不多，不过在叶子节点处存储的是`相应的列 + 行号`。这些索引也全部都是`二级索引`。

### MySQL中创建和删除索引的语句

创建表的时候指定需要建立索引的单个列或者建立联合索引的多个列：

```
CREATE TALBE 表名 (
    各种列的信息 ··· , 
    [KEY|INDEX] 索引名 (需要被索引的单个列或多个列)
)
```

修改表结构的时候添加索引：

```
ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列);
```

修改表结构的时候删除索引：

```
ALTER TABLE 表名 DROP [INDEX|KEY] 索引名;
```

