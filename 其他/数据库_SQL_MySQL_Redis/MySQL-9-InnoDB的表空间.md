# InnoDB的表空间

[TOC]

## 回忆一些旧知识

### 页面类型

InnoDB是以页为单位管理存储空间的，我们的聚簇索引（也就是完整的表数据）和其他的二级索引都是以`B+`树的形式保存到表空间的，而`B+`树的节点就是数据页。

### 页面通用部分

![1565776869599](pics\1565776869599.png)

任何类型的页都会包含这两个部分：

-   `File Header`：记录页面的一些通用信息
-   `File Trailer`：校验页是否完整，保证从内存到磁盘刷新时内容的一致性。

## 独立表空间结构

### 区（extent）的概念

表空间中的页实在是太多了，为了更好的管理这些页面，设计`InnoDB`的大叔们提出了`区`（英文名：`extent`）的概念。

![1565776951911](pics\1565776951911.png)

只要大致记得：表空间被划分为许多连续的`区`，每个区默认由64个页组成，每256个区划分为一组，每个组的最开始的几个页面类型是固定的就好了。

### 段（segment）的概念

引入`区`（`extent`）的概念，一个区就是在物理位置上连续的64个页。

在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照`区`为单位分配，甚至在表中的数据十分非常特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足填充满整个区），但是从性能角度看，可以消除很多的随机`I/O`。

设计`InnoDB`的大叔们对`B+`树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的`区`，非叶子节点也有自己独有的`区`。存放叶子节点的区的集合就算是一个`段`（`segment`），存放非叶子节点的区的集合也算是一个`段`。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。

PS：只需要知道 段是一些零散的页面以及一些完整的区的集合就好了。

### 区的分类

表空间的是由若干个区组成的，这些区大体上可以分为4种类型：

-   空闲的区：现在还没有用到这个区中的任何页面。
-   有剩余空间的碎片区：表示碎片区中还有可用的页面。
-   没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面。
-   附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。

4种类型的区也可以被称为区的4种状态（`State`），设计`InnoDB`的大叔们为这4种状态的区定义了特定的名词儿：

|   状态名    |         含义         |
| :---------: | :------------------: |
|   `FREE`    |       空闲的区       |
| `FREE_FRAG` |  有剩余空间的碎片区  |
| `FULL_FRAG` | 没有剩余空间的碎片区 |
|   `FSEG`    |   附属于某个段的区   |

需要再次强调一遍的是，处于`FREE`、`FREE_FRAG`以及`FULL_FRAG`这三种状态的区都是独立的，算是直属于表空间；而处于`FSEG`状态的区是附属于某个段的。

为了方便管理这些区，设计`InnoDB`的大叔设计了一个称为`XDES Entry`的结构

![1565777275806](pics\1565777275806.png)

#### XDES Entry链表

向表中插入数据本质上就是向表中各个索引的叶子节点段、非叶子节点段插入数据，也知道了不同的区有不同的状态，再回到最初的起点，捋一捋向某个段中插入数据的过程：

略...

#### 链表基节点

怎么找到某个链表的头节点或者尾节点在表空间中的位置呢？设计`InnoDB`的大叔当然考虑了这个问题，他们设计了一个叫`List Base Node`的结构，翻译成中文就是链表的基节点。

![1565777417712](pics\1565777417712.png)

#### 链表小结

综上所述，表空间是由若干个区组成的，每个区都对应一个`XDES Entry`的结构，直属于表空间的区对应的`XDES Entry`结构可以分成`FREE`、`FREE_FRAG`和`FULL_FRAG`这3个链表；每个段可以附属若干个区，每个段中的区对应的`XDES Entry`结构可以分成`FREE`、`NOT_FULL`和`FULL`这3个链表。每个链表都对应一个`List Base Node`的结构，这个结构里记录了链表的头、尾节点的位置以及该链表中包含的节点数。正是因为这些链表的存在，管理这些区才变成了一件so easy的事情。

### 段的结构

### 各类型页面详细情况

#### `FSP_HDR`类型

##### File Space Header部分

这个部分是用来存储表空间的一些整体属性的

##### XDES Entry部分

在上面。

#### `XDES`类型

#### `IBUF_BITMAP`类型

#### `INODE`类型

`INODE`类型的页就是为了存储`INODE Entry`结构而存在的

### Segment Header 结构的运用

### 真实表空间对应的文件大小

一开始表空间占用的空间自然是很小，因为表里边都没有数据嘛！不过别忘了这些`.ibd`文件是自扩展的，随着表中数据的增多，表空间对应的文件也逐渐增大。

## 系统表空间

### 系统表空间的整体结构

系统表空间与独立表空间的一个非常明显的不同之处就是在表空间开头有许多记录整个系统属性的页面

#### InnoDB数据字典

MySQL除了保存着我们插入的用户数据之外，还需要保存许多额外的信息

##### SYS_TABLES表

##### SYS_COLUMNS表

##### SYS_INDEXES表

##### SYS_FIELDS表

##### Data Dictionary Header页面

只要有了上述4个基本系统表，也就意味着可以获取其他系统表以及用户定义的表的所有元数据。

##### information_schema系统数据库

用户是不能直接访问`InnoDB`的这些内部系统表的，除非你直接去解析系统表空间对应文件系统上的文件。

```
mysql> SHOW TABLES LIKE 'innodb_sys%';
```

## 总结

略