# 计算机组成原理-实践

[TOC]

## 操作系统的演进

### 无操作系统

-   人工操作
-   用户独占
-   CPU等待人工操作
-   资源利用率很低

### 批处理系统

-   无需等待人工操作
-   批量输入任务
-   资源利用率提升
-   *多道程序设计
    -   早期批处理系统只能一次处理一个任务
    -   意义：多道程序设计使得批处理系统可以一次处理多个任务
    -   多道程序设计是指在计算机内存中同时存放多个程序
    -   多道程序在计算机的管理程序之下相互穿插运行
    -   对多道程序的管理是操作系统的重要功能

### 分时系统

-   人-机交互
-   多用户共享
-   及时调试程序
-   资源利用率提升

## 操作系统概览

### What&Why

>   KEY：管理硬件、提供用户交互的软件系统

#### What

-   操作系统是管理计算机硬件和软件资源的计算机程序
-   管理配置内存、决定资源供需顺序、控制输入输出设备等
-   操作系统提供让用户和系统交互的操作界面
-   操作系统的种类是多种多样的，不局限于计算机
-   从手机到超级计算机，操作系统可简单也可复杂
-   在不同的设备上，操作系统可向用户呈现多种操作手段

#### WHY

-   我们不可能直接操作计算机硬件
-   设备种类繁多复杂，需要统一界面
-   操作系统的简易性使得更多人能够使用计算机

### 操作系统的基本功能

>   操作系统统一管理着计算机资源

-   用户无需面向硬件接口编程
-   IO设备管理软件，提供读写接口
-   文件管理软件，提供操作文件接口 

![1572707973411](pics/1572707973411.png)

>   操作系统提供了用户与计算机之间的接口

-   图像窗口形式
-   命令形式
-   系统调用形式

### 操作系统相关概念

#### 并发性

-   并行是指两个或多个事件可以在同一个时刻发生（强调某一时刻）
-   并发是指两个或多个事件可以在同一个时间间隔发生（强调某个时段）

![1572708288289](pics/1572708288289.png)

#### 共享性

-   共享性表现为操作系统中的资源可供多个并发的程序共同使用
-   这种共同使用的形式称之为资源共享
-   多个程序可以同时使用主存资源
-   资源共享根据属性可分为两种方式
    -   互斥共享形式
        -   当资源被程序A占用时，其他想使用的话只能等待
        -   只有进程A使用完以后，其他进程才可以使用该资源
    -   同时访问形式
        -   某种资源在一段时间内并发地被多个程序访问
        -   这种“同时”是宏观的，从宏观去看该资源可以被同时访问

#### 虚拟性

-   虚拟性表现为把一个物理实体转变为若干个逻辑实体
-   物理实体是真实存在的，逻辑实体是虚拟的
-   虚拟的技术主要有时分复用技术和空分复用技术
    -    时分复用技术
        -   优势
            -   资源在时间上进行复用，不同程序并发使用
            -   多道程序分时使用计算机的硬件资源
            -   提高资源的利用率
        -   虚拟处理器技术
            -   借助多道程序设计技术
            -   为每个程序建立进程
            -   多个程序分时复用处理器
        -   虚拟设备技术
            -   物理设备虚拟为多个逻辑设备
            -   每个程序占用一个逻辑设备
            -   多个程序通过逻辑设备并发访问
    -   空分复用技术
        -   优势
            -   空分复用技术用来实现虚拟磁盘、虚拟内存等
            -   提高资源的利用率，提升编程效率
        -   虚拟磁盘技术
            -   物理磁盘虚拟为逻辑磁盘
            -   C、D、E等逻辑盘
            -   使用起来更加安全、方便
        -   虚拟内存技术
            -   在逻辑上扩大程序的存储容量
            -   使用比实际内存更大的容量
            -   大大提升编程效率

#### 异步性

-   在多道程序环境下，允许多个进程并发执行
-   进程在使用资源时可能需要等待或放弃
-   进程的执行并不是一气呵成的，而是以走走停停的形式推进

>   进程以不可预知的速度向前推进
>
>   -   何时执行
>   -   何时暂停
>   -   何时完成

## 进程管理

### 进程管理之进程实体

#### 为什么需要进程

>   -   没有配置OS之前，资源属于当前运行的程序
>   -   配置OS之后，引入多道程序设计的概念
>   -   合理的隔离资源、运行环境，提升资源利用率

>   多道程序设计的意义非凡

-   进程是系统进行资源分配和调度的基本单位
-   进程作为程序独立运行的载体保障程序正常执行(保障运行，多个进程可能使用相同的IO设备，进程在此起到了保存资源的作用)
-   进程的存在使得操作系统资源的利用率大幅提升

#### 进程的实体

##### 主存中的进程形态

>   总结起来分为四块：
>
>   -   进程标识符
>   -   处理机状态
>   -   进程调度信息
>   -   进程控制信息

###### 标识符

-   标识符唯一标记一个进程，用于区别其他进程

###### 状态

-   标记进程的进程状态，如：运行态

###### 程序计数器

-   进程即将被执行的下一条指令的地址

内存指针

-   程序逻辑代码、进程数据相关指针

###### 上下文数据

-   进程执行时处理器存储的数据（重要）

###### IO状态信息

-   被进程IO操作所占用的文件列表

###### 记账信息

-   使用处理器时间、时钟数总和等进程与线程（调试，获取状态时起作用）

>   进程控制块（PCB）
>
>   -   用于描述和控制进程运行的通用数据结构
>   -   记录进程当前状态和控制进程运行的全部信息
>   -   PCB的使得进程是能够独立运行的基本单位
>   -   PCB是操作系统进行调度经常会被读取的信息
>   -   PCB是常驻内存的，存放在系统专门开辟的PCB区域内

##### 进程与线程

###### 线程

>   注意两点：
>
>   -   一个进程可以有一个或多个线程
>   -   进程的线程共享进程资源

-   线程是操作系统进行运行调度的最小单位（CPU调度进程实际上是调度进程里的线程）
    -   进程是系统进行资源分配和调唐的基本单位
-   包含在进程之中，是进程中实际运行工作的单位
-   一个进程可以并发多个线程，每个线程执行不同的任务
-   进程管理之五状态模型

###### 对比

|      | 进程               | 线程       |
| :--: | :----------------: | :--------: |
| 资源 | 资源分配的基本单位 | 不拥有资源 |
| 调度 | 独立调度的基本单位 | 独立调度的最小单位 |
| 系统开销 | 进程系统开销大 | 线程系统开销小 |
| 通信 | 进程IPC | 读写同一进程数据通信 |

>   进程系统开销大原因：管理多个线程并需要分配资源

### 进程管理之五状态模型

#### 就绪状态

-   当进程被分配到除CPU以外所有必要的资源后
-   只要再获得CPU的使用权，就可以立即运行
-   其他资源都准备好、只差CPU资源的状态为就绪状态
-   在一个系统中多个处于就绪状态的进程通常排成一个队列

#### 执行状态

-   进程获得CPU，其程序正在执行称为执行状态
-   在单处理机中，在某个时刻只能有一个进程是处于执行状态

#### 阻塞状态

-   进程因某种原因如：其他设备未就绪而无法继续执行
-   从而放弃CPU的状态称为阻塞状态

#### 创建状态

过程：分配PCB—>插入就绪队列

-   创建进程时拥有PCB但其他资源尚未就绪的状态称为创建状态
-   操作系统提供fork函数接口创建进程

#### 终止状态

过程：系统清理—>PCB归还

-   进程结束由系统清理或者归还PCB的状态称为终止状态

#### 图示

![1572749945586](pics/1572749945586.png)

### 进程管理之进程同步

#### 为什么需要进程间同步

经典问题：生产者-消费者问题，哲学家进餐问题

-   根源问题是：彼此相互之间没有通信
    -   “如果生产者通知消费者我已经完成一件生产"
    -   “哲学家向旁边哲学家说我要进餐了"
-   需要进程间的同步原因
    -   对竞争资源在多进程间进行使用次序的协调
    -   使得并发执行的多个进程之间可以有效使用资源和相互合作

#### 进程间同步的原则

##### 临界资源

临界资源指的是一些虽作为共享资源却又无法同时被多个线程共同访问的共享资源。当有进程在使用临界资源时，其他进程必须依据操作系统的同步机制等待占用进程释放该共享资源才可重新竞争使用共享资源。

##### 进程间同步的四个原则

-   空闲让进：资源无占用，允许使用
-   忙则等待：资源有占用，请求进程等待
-   有限等待：保证有限等待时间能够使用资源
-   让权等待：等待时，进程需要让出CPU（保证CPU高效利用的一个前提）

##### 进程间同步的三个方法

-   消息队列
-   共享存储
-   信号量

#### 线程同步

>   -   进程内多线程也需要同步
>
>   -   进程的线程共享进程资源

##### 线程同步的四个方法

-   互斥量
-   读写锁
-   自旋锁
-   条件变量

### Linux的进程管理

#### Linux进程的相关概念

##### 进程的类型

###### 前台进程

-   前台进程就是具有终端，可以和用户交互的进程

###### 后台进程

-   与前台进程相对，没有占用终端的就是后台进程
-   后台程序基本上不和用户交互，优先级比前台进程低
-   将需要执行的命令以“&”符号结束

###### 守护进程

-   守护（daemon）进程是特殊的后台进程
-   很多守护进程在系统引导的时候启动，一直运行直到系统关闭
-   Linux有很多典型的守护进程
    -   sshd，crond，mysqld，httpd
    -   进程名字以“d”结尾的一般都是守护进程

##### 进程的标记

###### 进程ID

-   进程ID是进程的唯一标记，每个进程拥有不同的ID
-   进程ID表现为一个非负整数，最大值由操作系统限定
-   父子进程关系可以通过pstree命令查看
-   特数进程
    -   ID为0的进程为idle进程，是系统创建的第一个进程
    -   ID为1的进程为init进程，是0号进程的子进程，完成系统初始化
    -   Init进程是所有用户进程的祖先进程

###### 进程的状态标记

| 状态符号 |                           状态说明                           |
| :------: | :----------------------------------------------------------: |
|    R     |             （TASK_RUNNING），进程正处于运行状态             |
|    S     |          （TASK_INTERRUPTIBLE），进程正处于睡眠状态          |
|    D     |    （TASK_UNINTERRUPTIBLE），进程正在处于I0等待的睡眠状态    |
|    T     |             （TASK STOPPED），进程正处于暂停状态             |
|    Z     | （TASK_DEAD or EXIT_ZOMBIE），进程正处于退出状态，或僵尸进程 |

>   操作命令示例：ps -aux | grep PID

#### 操作Linux进程的相关命令

##### ps命令

-   ps命令常用于显示当前进程的状态
-   ps命令常配合aux参数或ef参数和grep命令检索特定进程

```
ps -ef --forest 查看进程树
ps -aux -sort=-pcpu 按照CPU使用情况排序
ps -aux -sort=-pmem 按照内存使用情况排序
```

##### top命令

```
top 查看机器状态信息
```

##### kill命令

-   kill命令发送指定信号给进程
-   kill-1可以查看操作系统支持的信号
-   只有（SIGKILL9）信号可以无条件终止进程，其他信号进程有权忽略

```
kill -9 PID 无条件停止PID
```

## 作业管理

### 作业管理之进程调度

#### 进程调度概述

-   进程调度是指计算机通过决策决定哪个就绪进程可以获得CPU使用权（与多道程序设计有关）
-   保留旧进程的运行信息，请出旧进程（收拾包袱）
-   选择新进程，准备运行环境并分配CPU（新进驻）

##### 就绪队列的排队机制

-   将就绪进程按照一定的方式排成队列，以便调度程序可以最快找到就绪进程

##### 选择运行进程的委派机制

-   调度程序以一定的策略选择就绪进程，将CPU资源分配给它

##### 新老进程的上下文切换机制

-   保存当前进程的上下文信息，装入被委派执行进程的运行上下文
-   老进程的上下文存储在主存中，再将新进程的上下文调入高速缓存中

**老进程还没执行完呢**？

##### 非抢占式的调度

-   处理器一旦分配给某个进程，就让该进程一直使用下去
-   调度程序不以任何原因抢占正在被使用的处理器
-   直到进程完成工作或因为IO阻塞才会让出处理器

##### 抢占式的调度

-   允许调度程序以一定的策略暂停当前运行的进程
-   保存好旧进程的上下文信息，分配处理器给新进程

##### 两种方式的优略

|          | 抢占式调度       | 非抢占式调度       |
| -------- | ---------------- | ------------------ |
| 系统开销 | 频繁切换，开销大 | 切换次数少，开销小 |
| 公平性   | 相对公平         | 不公平             |
| 应用     | 通用系统         | 专用系统           |

#### 进程调度算法

##### 先来先服务调度算法

##### 短进程优先调度算法

-   调度程序优先选择就绪队列中估计运行时间最短的进程
-   短进程优先调度算法不利于长作业进程的执行

##### 高优先权优先调度算法

-   进程附带优先权，调度程序优先选择权重高的进程
-   高优先权优先调度算法使得紧迫的任务可以优先处理
-   前台-后台进程处理也是使用高低优先权处理，前台进程保证时效性

##### 时间片轮转调度算法

-   按先来先服务的原则排列就绪进程
-   每次从队列头部取出待执行进程，分配一个时间片执行
-   是相对公平的调度算法，但不能保证及时响应用户

### 作业管理之死锁

#### 死锁

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

#### 死锁的产生

##### 竞争资源

-   共享资源数量不满足各个进程需求
-   各个进程之间发生资源竞争进程导致死锁
-   等待请求的资源被释放
-   自身占用资源不释放

##### 进程调度顺序不当

##### 死锁的四个必要条件

-   互斥条件

    -   进程对资源的使用是**排他性的使用**
    -   某资源只能由一个进程使用，其他进程需要使用只能等待

-   请求保持条件

    -   进程至少保持一个资源，又提出新的资源请求
    -   新资源被占用，请求被阻塞
    -   被阻塞的进程不释放自己保持的资源

-   不可剥夺条件

    -   进程获得的资源在未完成使用前不能被剥夺
    -   获得的资源只能由进程自身释放

-   环路等待条件

    -   发生死锁时，必然存在进程-资源环形链

    -   图示

        ![1572768125270](pics/1572768125270.png)

#### 死锁的处理

##### 预防死锁的方法

>   破坏死锁的四个条件的一个或者多个必要条件即可

###### 摒弃请求保持条件

-   系统规定进程运行之前，一次性申请所有需要的资源
    进程在运行期间不会提出资源请求，从而摒弃请求保持条件

###### 摒弃不可剥夺条件

-   当一个进程请求新的资源得不到满足时，必须释放占有的资源
-   进程运行时占有的资源可以被释放，意味着可以被剥夺

###### 摒弃环路等待条件

-   可用资源线性排序，申请必须按照需要递增申请
-   线性申请不再形成环路，从而摒弃了环路等待条件
-   A—>B—>C—>D—>E，按顺序申请

##### 银行家算法 

>   6-8 11.50 开始

-   是一个可操作的著名的避免死锁的算法
-   以银行借贷系统分配策略为基础的算法
-   客户申请的贷款是有限的，每次申请需声明最大资金量
-   银行家在能够满足贷款时，都应该给用户贷款
-   客户在使用贷款后，能够及时归还贷款
-   观察可分配资源表，哪个进程条件满足的，申请给予哪一个进程

## 存储管理

### 存储管理之内存分配与回收

#### 存储管理前情回顾

>   早期计算机编程并不需要过多的存储管理
>
>   随着计算机和程序越来越复杂，存储管理成为必要

-   确保计算机有足够的内存处理数据
-   确保程序可以从可用内存中获取一部分内存使用
-   确保程序可以归还使用后的内存以供其他程序使用

#### 内存分配的过程

##### 单一连续分配

>   划分为两块，系统区，用户区，系统使用系统区，用户使用用户区

-   单一连续分配是最简单的内存分配方式
-   只能在单用户、单进程的操作系统中使用

##### 固定分区分配

-   固定分区分配是支持多道程序的最简单存储分配方式
-   内存空间被划分为若干固定大小的区域
-   每个分区只提供给一个程序使用，互不干扰

##### 动态分区分配

-   根据进程实际需要，动态分配内存空间
-   相关数据结构、分配算法
    -   动态分区空闲表数据结构
        -   使用数组保存对应标志位标记，0空，1占用
    -   动态分区空闲链数据结构
        -   使用双向链表把节点链接起来
        -   节点需记录可存储的容量
    -   动态分区分配算法
        -   首次适应算法（FF算法）
            -   分配内存时从开始顺序查找适合内存区
            -   若没有合适的空闲区，则该次分配失败
            -   每次从头部开始，使得头部地址空间不断被划分（弊端）
            -   改良：循环适应算法，从上次检索末尾开始
        -   最佳适应算法（BF算法）
            -   最佳适应算法要求空闲区链表**按照容量大小排序**
            -   遍历空闲区链表找到最佳合适空闲区
            -   从小到大遍历，避免了大材小用的情况
        -   快速适应算法（QF算法）
            -   快速适应算法要求有多个空闲区链表
            -   每个空闲区链表存储一种容量的空闲区（一种容量一个链表）

#### 内存回收的过程

##### 回收区在空闲区后面

-   不需要新建空闲链表节点
-   只需要把空闲区1的容量增大为空闲区即可（空闲区直接囊括回收区）

##### 回收区在空闲区前面

-   将回收区与空闲区合并
-   新的空闲区使用回收区的地址

##### 回收区前后都是空闲区

-   将空闲区1、空闲区2和回收区合并
-   新的空闲区使用空闲区1的地址

##### 单独一个回收区

-   为回收区创建新的空闲节点
-   插入到相应的空闲区链表中去

### 存储管理之段页式存储管理



### 存储管理之虚拟内存



### Linux的存储管理



## 文件管理

### 操作系统的文件管理



### Linux的文件系统



### Linux文件的基本操作



## 设备管理

### 操作系统的设备管理