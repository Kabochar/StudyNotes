# 31丨为什么大部分RDBMS都会支持MVCC？

[TOC]

## 前情

事务有 4 个隔离级别，以及可能存在的三种异常问题，如下图所示

![1575527657737](pics/SQL_基础理论\1575527657737.png)

在 MySQL 中，默认的隔离级别是可重复读，可以解决脏读和不可重复读的问题，但不能解决幻读问题。如果我们想要解决幻读问题，就需要采用串行化的方式，也就是将隔离级别提升到最高，但这样一来就会大幅降低数据库的事务并发能力。

MVCC 机制的设计就是用来解决，可以不采用锁机制，而是通过乐观锁的方式来解决不可重复读和幻读问题。它可以在大多数情况下替代行级锁，降低系统的开销。

## 疑问

MVCC 机制的思想是什么？为什么 RDBMS 会采用 MVCC 机制？

在 InnoDB 中，MVCC 机制是如何实现的 ？

Read View 是如何工作的？

为什么隔离级别为读未提交时，不适用于 MVCC 机制呢？

“读未提交”隔离级别不需要多版本数据。

读已提交和可重复读这两个隔离级别的 Read View 策略有何不同？

“读已提交”时，每次SELECT操作都创建Read View，无论SELECT是否相同，所以可能出现前后两次读到的结果不等，即不可重复读。

“可重复读”时，首次SELECT操作才创建Read View并复用给后续的相同SELECT操作，前后两次读到的结果一定相等，避免了不可重复读。

## MVCC 是什么，解决了什么问题

MVCC 的英文全称是 Multiversion Concurrency Control，中文翻译过来就是多版本并发控制技术。从名字中也能看出来，MVCC 是通过数据行的多个版本管理来实现数据库的并发控制，简单来说**它的思想就是保存数据的历史版本**。

这样就可以通过比较版本号决定数据是否显示出来（具体的规则后面会介绍到），读取数据的时候不需要加锁也可以保证事务的隔离效果。

通过 MVCC 我们可以解决以下几个问题：

-   读写之间阻塞的问题。
    -   通过 MVCC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。
-   降低了死锁的概率。
    -   这是因为 MVCC 采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。
-   解决一致性读的问题。
    -   一致性读也被称为快照读，当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。

## 什么是快照读，什么是当前读

什么是快照读呢？快照读读取的是快照数据。不加锁的简单的 SELECT 都属于快照读

```

SELECT * FROM player WHERE ...
```

当前读就是读取最新数据，而不是历史版本的数据。加锁的 SELECT，或者对数据进行增删改都会进行当前读

```
SELECT * FROM player LOCK IN SHARE MODE;

SELECT * FROM player FOR UPDATE;

INSERT INTO player values ...

DELETE FROM player WHERE ...

UPDATE player SET ...
```

快照读就是普通的读操作，而当前读包括了加锁的读取和 DML 操作。

MVCC 可以解决读写互相阻塞的问题，这样提升了效率，同时因为采用了乐观锁的思想，降低了死锁的概率。

## InnoDB 中的 MVCC 是如何实现的？

MVCC 没有正式的标准，所以在不同的 DBMS 中，MVCC 的实现方式可能是不同的

多版本对应的就是 MVCC 前两个字母的释义：Multi Version，我们需要了解和它相关的数据都有哪些，存储在哪里。这些数据包括事务版本号、行记录中的隐藏列和 Undo Log。

### 事务版本号

每开启一个事务，我们都会从数据库中获得一个事务 ID（也就是事务版本号），这个事务 ID 是自增长的，通过 ID 大小，我们就可以判断事务的时间顺序。

### 行记录的隐藏列

InnoDB 的叶子段存储了数据页，数据页中保存了行记录，而在行记录中有一些重要的隐藏字段

-   db_row_id：隐藏的行 ID，用来生成默认聚集索引。
    -   创建数据表的时候没有指定聚集索引，这时 InnoDB 就会用这个隐藏 ID 来创建聚集索引
    -   采用聚集索引的方式可以提升数据的查找效率。
-   db_trx_id：操作这个数据的事务 ID，也就是最后一个对该数据进行插入或更新的事务 ID。
-   db_roll_ptr：回滚指针，也就是指向这个记录的 Undo Log 信息。

![1575528172441](pics/SQL_基础理论\1575528172441.png)

### Undo Log

InnoDB 将行记录快照保存在了 Undo Log 里，我们可以在回滚段中找到它们

![1575528199527](pics/SQL_基础理论\1575528199527.png)

回滚指针将数据行的所有快照记录都通过链表的结构串联了起来，每个快照的记录都保存了当时的 db_trx_id，也是那个时间点操作这个数据的事务 ID。

如果我们想要找历史快照，就可以通过遍历回滚指针的方式进行查找。

## Read View 是如何工作的

在 MVCC 机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在 Undo Log 里。

如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢？这时就需要用到 Read View 了，它帮我们解决了行的可见性问题。

Read View 保存了当前事务开启时所有活跃（还没有提交）的事务列表，换个角度你可以理解为 Read View 保存了不应该让这个事务看到的其他的事务 ID 列表。

在 Read VIew 中有几个重要的属性

trx_ids，系统当前正在活跃的事务 ID 集合。

low_limit_id，活跃的事务中最大的事务 ID。

up_limit_id，活跃的事务中最小的事务 ID。

creator_trx_id，创建这个 Read View 的事务 ID。

当查询一条记录的时候，系统如何通过多版本并发控制技术找到它：

-   首先获取事务自己的版本号，也就是事务 ID；
-   获取 Read View；
-   查询得到的数据，然后与 Read View 中的事务版本号进行比较；
-   如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；
-   最后返回符合规则的数据。

InnoDB 中，MVCC 是通过 Undo Log + Read View 进行数据读取，Undo Log 保存了历史快照，而 Read View 规则帮我们判断当前版本的数据是否可见。

在隔离级别为读已提交（Read Commit）时，一个事务中的每一次 SELECT 查询都会获取一次 Read View。

在读已提交的隔离级别下，同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生不可重复读或者幻读的情况。

当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View

## InnoDB 是如何解决幻读的

出现幻读的原因是在读已提交的情况下，InnoDB 只采用记录锁（Record Locking）。这里要介绍下 InnoDB 三种行锁的方式：

-   记录锁：针对单个行记录添加锁。
-   间隙锁（Gap Locking）：可以帮我们锁住一个范围（索引之间的空隙），但不包括记录本身。采用间隙锁的方式可以防止幻读情况的产生。
-   Next-Key 锁：帮我们锁住一个范围，同时锁定记录本身，相当于间隙锁 + 记录锁，可以解决幻读的问题。

在隔离级别为可重复读时，InnoDB 会采用 Next-Key 锁的机制，帮我们解决幻读问题。

## 总结

需要记住，MVCC 的核心就是 Undo Log+ Read View，“MV”就是通过 Undo Log 来保存数据的历史版本，实现多版本的管理，“CC”是通过 Read View 来实现管理，通过 Read View 原则来决定数据是否显示。

同时针对不同的隔离级别，Read View 的生成策略不同，也就实现了不同的隔离级别。