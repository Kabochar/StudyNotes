# 计算机网络
[TOC]

<!-- more -->
## 五层协议-体系结构

中和 OSI 和 TCP/IP 的优点，采用 只有 五层协议的体系结构。

### 应用层

任务：通过应用程序的交互来完成特定任务的应用。

定义：应用进程间的通信 和 交互的规则。

不同的网络应用需要不同的应用层协议。

应用层交互数据的数据单元称为 报文。

协议：HTTP，DNS，SMTP

设计 HTTP 原因：提供一种可以发送和接收 HTML 文本的方法

### 运输层

任务：向 两台主机之间提供通用的数据传输服务。应用进程使用该该服务传输应用层报文。
运输层分为：复用，分用。

-   复用：多个运输层的进程可以使用下面的运输层的服务。

-   分用：运输层收到的信息分别交付给上面应用层的相应进程。

    主要协议：UDP，TCP

    UDP：无连接，尽最大努力交付，面向报文，没有拥塞控制，支持一对一，一对多，多对多，多对一，首部开销小。

    TCP：面向连接，通信前需要确认，只能存在两个端点，提供一种可靠的交付服务，提供双全工通信，面向字节流。TCP 把应用程序下来的数据仅仅看作一串无结构的字节流。

### 网络层

任务：选择合适的路由 和 交换节点，确保数据及时传输。

发送数据时，网络层把 运输层产生的报文段 或 用户数据报封装成 分组 和  包 进行传递。

网路网络层使用 IP 协议。分组可叫 IP 数据报，数据报。

注意：网络层 中的网路特指，网络通信模型中的网络；互联网使用的网络层协议：无连接的网际协议，许多路由选择协议。

网络层 亦称 IP 层，网际层。

### 数据链路层

任务：节点在进行传输数据时，数据链路层把网路层交付的数据报 封装成 帧，在节点之间的链路上传送。

每一帧包括必要的 数据 和 必要的控制信息。

控制信息的作用：

1，接收数据，知道 一个帧 从哪开始，哪结束。可以更好的截取数据，交给网络层。

2，检测帧有无差错。存在差错，直接抛弃，避免浪费资源。

3，改正数据在链路层传输时出现差错，采用可靠性传输协议来纠正。数据链路层要检错，而且还要纠错

### 物理层

任务：实现相邻计算机之间比特流的透明传送，尽可能 屏蔽掉具体传送介质 和 物理设备的差异。

物理层上的传送单位，比特

透明比特流：经实际电路传送后没有发生变化。

特殊：0和1表示的电气特性及表示信号意义的逻辑特性

## 以太网

星型拓补结构局域网。

早期：使用集线器进行连接。

目前：使用交换机。交换机是一种数据链路层设备。

## IP 数据报

样式：首部 + 数据部分

首部：包含，版本（IP类型），首部长度，区分服务，总长度，生存时间，协议（TCP or UDP），首部校验和，标识，片偏移。



ARP 协议：地址解析协议 ARP

ARP 实现由 IP 地址获得 MAC 地址。

ARP 首先通过本地的 IP 到 MAC 地址的映射表查找。如果没有，则进行广播，搜索 IP 对应的 MAC 地址。

## IMCP 协议：国际控制报文协议 ICMP 

ICMP 为了更有效转发 IP 数据和提高交付成功的机会。

它封装在 IP 数据报中。

ICMP 报文分为 差错报告报文和询问报文。

应用：Ping，测试主机之间的连通性；Traceroute，跟踪一个分组从源点到终点的路径。

## TCP 可靠传输：

使用超时重传实现。

一个报文段从发送再到接收到确认所经过的时间称为 往返 RTT。

## TCP 拥塞控制：

网络拥塞，分组丢失，发送发继续重发，导致网络拥塞更严重。

当出现拥塞，应 控制发送发的速率。

流量控制：为了让接收方来得及接收；拥塞控制：为了降低整个网络的拥塞程度。

TCP 通过四个算法进行拥塞控制：慢开始，拥塞避免，快重传，快恢复。

此时，发送方需要维持一个 拥塞窗口(cwnd) 的状态变量。

## DNS：域名系统

分布式数据库，提供 主机名和 IP 地址之间相互交换的服务。分布式数据库：每个站点只保留它自己的那部分数据。

DNS 可使用 UDP or TCP 进行传输，使用  53 端口。

大多数情况使用 UDP，要求域名解析器和域名服务器处理自己的处理超时和重传保证可靠性。

使用 TCP 场景：返回的相应超过 512 字节。区域传送。

## FTP：文本传输协议

使用 TCP 连接。
需要两个连接传送一个文件：控制连接，数据连接。

控制连接使用 21 端口。

根据服务器的主动性，分为 主动和被动性。

主动，服务器端口 20 ，客户端随机，大于 1024

被动，客户端端口号自定义，服务端端口号随机。

被动性会导致服务端安全性减弱，因开放过多端口号。

## HTTP

### GET，POST 差异性：

作用：GET 用于获取资源，POST 用于传送实体主体。

参数：GET 以查询字符串出现在 URL， POST 参数存储在实体主体中。

安全：GET是安全的，POST 会改变状态。（安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。）

幂等性：GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。

### 可缓存性

需要缓存，需满足：

1，请求报文的HTTP方法本身可以缓存，包括 GET 和 HEAD 方法，PUT 和 DELETE 不可缓存。POST 在大多数情况不能缓存。

2，相应报文的状态码可以缓存。

3，响应报文的 Cache-Control 首部字段没有指定。

### XMLHttpRequest

了解：XMLHttpRequest 是一个 API，它为客户端提供了 在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。

1，在使用  XMLHttpRequest 的 POST ，浏览器会发送 Header 再发送 data，但并不是所有的浏览器都会这么做。

2，GET 方法的 HEADER 和 Data 会一起发送。

状态码：服务器返回的响应报文中第一行为状态码。

1XX 信息
2XX 成功
3XX 重定向
4XX 客户端错误
5XX 服务器错误

### Cookie

出现，HTTP/1.1，用来保存状态信息

Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览之后向服务器再次发起请求时被携带上，用户告知服务器两个请求是否来自于同一浏览器。

新的浏览器已经允许开发者直接将数据存储到本地，如使用  Web storage API（本地存储和会话存储）或 IndexedDB。

1，用途：状态会话管理，个性化设置，浏览器行为跟踪。
2，创建过程：服务器 响应报文包含 set-cookie 首部字段，客户端得到响应报文后把 Cookie 保存到浏览器中。
3，分类：会话期 Cookie，持久性 Cookie
4，作用域：Domain 标识指定哪些主机接收 Cookie
5，JavaScript：通过 document.cookie 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。
6，HttpOnly：标记为 HTTPOnly 的 Cookie 不能被 JavaScript 脚本调用。
7，Secure：标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给给服务端。
8，Session：利用 Session 将 cookie 存储在 服务器端，信息更加安全。也可以通过 Redis 存储 Session。
9，浏览器禁用 Cookie：此时只能使用 Session，可以使用 URL 重写技术，将 Session 作为 URL 的参数进行传递。
10，Cookie 和 Session 选择
Cookie 只能存储 ASCii字符串，Session 可以存储任意类型，参考不同的场景；
Cookie 存储在浏览器中，易被恶意查看。
Session 开销大，不建议将所有的用户信息存储在 Session中。

### 缓存

1，优点：缓解服务器压力，降低客户端获取资源的延迟。
2，实现方式：让代理人服务器继续缓存，让客户段进行缓存。
3，Cache-Control：
3.1：禁止进行缓存- no-store

3.2：强制确认缓存- no-cache

3.3：私有缓存和公共缓存- private || public

3.4：缓存过期机制- max-age=XXX || Expires：date

4，缓存验证
ETag：资源的唯一标识。

If-None-Match：可以将缓存资源的值放入 If-None-Match ，判断于最新的 ETag 值是否一致。
Last-Modified：弱校验器。ETag 的备用方法。

If-Modified-Since：客户端 带上 If-Modified-Since 验证缓存，服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。

如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 304 Not Modified 响应。

### 连接管理

1，长连接：只需要建立一次 TCP 连接就可进行多次 HTTP 通信。

-   从 HTTP/1.1 开始默认是 长连接，如果要断开连接，要客户端 or 服务器端提出断开，使用 Connection : close；
-   在 HTTP/1.1 之前默认是 短连接，如果需要使用长连接，则使用 Connection : Keep-Alive。
    2，流水线：在同一条长连接上发出连续的请求，而不用等待响应返回，可以避免连接延迟。

### 加密

1，对称性加密：加密解密使用同一把锁。优：运算快。缺：无法安全传输。

2，非对称性加密：加密解密使用不同的锁。优：更安全公开密钥传输通信。缺：运算速度慢。

3，HTTPs 加密方式：混合加密。使用 非对称性密钥加密 传输 对称密钥（保证传输过程安全），使用 对称密钥 加密 进行 通信 （保证通信过程的效率）。

### 认证：使用 证书 对通信方 进行认证。

进行HTTPs 通信时，服务器把证书发送到客户端，客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，即可开始通信。

### 完整性保护：SSL。SSL 提供报文摘要来进行完整性保护。

HTTP 也提供了 MD5 报文摘要功能，但不是安全的。

HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。

HTTPS 的缺点：需要进行加密解密过程，速度会减慢；需要支付证书授权的高额费用。

### HTTP/2.0

HTTP/1.X 缺陷
HTTP/1.x 以牺牲性能为代价实现简单：客户端需要多个连接才能比并发和缩短延迟。不会压缩请求和响应首部，导致不必要的网络流量。不支持有效的资源优先级，使底层TCP连接利用率低下。

### 二进制分帧层

HTTP/2.0 将报文分成  HEADERS 帧 and DATA 帧，它们都是二进制帧。

通过过程只会有一个 TCP 连接，它承载着任意数量的双向数据流 STREAM。

-   一个数据流都有一个唯一标识符 和 可选的优先级信息，用于承载双向信息。
-   消息，与 逻辑请求 or 响应对应的完整的一系列帧。
-   帧，最小的通信到位，不同数据流的帧可以交错发送，然后根据每个帧头数据流标识符重新组装。

### 服务器推送

HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，这样，客户端不需要再次发起请求。

### 首部压缩

HTTP/1.0 首部带有大量信息，而且需要每次重复发送。

HTTP/2.0 要求客户端 和 服务器端 同时 维护 和 更新 一个包含之前见过的首部字段表，避免了重复传输。

HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。

HTTP 版本比较
缺-

### Socket

I/O 模型：Unix五种。堵塞式 IO，非堵塞式 IO，IO 复用，信号驱动式 IO，异步 IO

套接字的输入操作：1，等待数据从网络到达。数据到达时，复制到内核中某个缓冲区。
2，数据从内核缓冲区复制到应用进程缓冲区。

阻塞式 I/O

应用进程堵塞，直到数据从内核缓冲区复制到应用进程中才返回。当堵塞时，其他应用程序还能运行，且不占用 CPU 时间，CPU 利用效率高。

非阻塞式 I/O

应用程序执行系统调用，内核返回一个状态码。应用程序可以继续执行，但需要不断执行系统调用来获知 IO 是否完成（这种方式被称为 轮询，polling）。CPU 要处理更多系统调用，CPU 利用率低。

I/O 复用

使用 select 和 pull 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被堵塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核中复制到进程中。
它可以让单个进程具有处理多个 IO 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。
相比多线程，多进程，IO 复用不需要进程线程创建和切换的开销，系统开销更小。

信号驱动 I/O

应用程序使用 sigaction 系统调用，内核立即返回，应用程序可以继续执行，即，等待数据阶段应用程序是非堵塞的。内核在数据到达时，向应用程序发送 SIGIO 信号，应用程序收到后在信号处理程序中调用 revfrom 将数据 从内核复制到应用程序中。
相比 非堵塞式 IO 的 轮询 Pull 方式，信号驱动 IO CPU 利用率更高。

异步 IO

应用程序执行 aio_read 系统调用会立即返回，应用程序可以继续执行，不会被堵塞，内核会在所有操作完成之后向应用程序发送信号。
异步 I/O 与信号驱动 I/O 的区别：异步 I/O 的信号是 通知 应用进程 I/O 完成，而 信号驱动 I/O 的信号是 通知应用进程 可以 开始 I/O。

------

多路复用

SELECT
缺-
POLL
缺-



