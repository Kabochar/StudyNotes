秒杀系统设计-李云华-极客时间



## 设计系统- 5 个 结构原则

### 架构原则：4 要 1 不要

### 1，请求数据 要尽量少，减少 CPU 消耗

WHY？

-   首先，这些数据在网络上传输需要时间，其次不管是请求数据还是返回许哟啊都需要服务器做处理，而故武器在写网络时通常要做压缩和字符编码，很消耗 CPU。
-   其次，完成某些业务逻辑需要读取和存储数据，需要与后台服务以及数据库打交道。调用其他服务会涉及数据的序列化和反序列化，大大消耗 CPU，也会增加延迟。

HOW？

-   简化秒杀页面的大小，也掉不必要的页面装修效果。
-   数据越简单、越小越好。

### 2，减少额外请求，减少加载时间

WHY？

-   渲染页面需要其他的额外请求。
-   做三次握手。
-   请求不同域名，涉及 DNS 解析。

HOW？

-   减少请求数。常用：合并 CSS 和 JavaScript 文件，多个 JavaScript  文件合并成一个文件，在 URL 中用 逗号隔开。

### 3，访问路径尽量短，减少节点消耗

路径：用户请求发出请求到返回数据这个过程中，需求经过的中间的节点数。

WHY？

-   每经过一个节点，一般都会产生一个新的 Socket 连接。
-   每增加一个节点，会增加新的不确定性。

HOW？

-   减少中间节点，减少网络传输耗时。
-   多个相互强依赖应用合并部署在一起。

### 4，强依赖尽量少，减少加载时间

依赖：完成一次用户请求必须依赖的系统或者服务，指 强依赖。

WHY？

-   非要不可信息（弱连接），非紧急情况可以去掉。

HOW？

-   给系统分级，O 级，1 级...

PS：0 级系统要尽量减少对 1 级系统的强依赖。

### 5，不要有单点，要有备份

WHY？

-   单点意味没有备份，风险不可控。

HOW？

-   如果避免单点：避免将服务的状态和机器绑定，把服务无状态化，这样服务就可以在机器中随机移动。
-   如何把服务的状态和机器解耦？把和机器的配置动态化，这些参数可以通过配置中心来动态推送，在服务启动时拉取，可以在这些配置中心设置一些规则来方便改变映射关系。

**架构是一种平衡的艺术，最好的架构一旦脱离了它所适应的场景，一切都将是空谈。**

## 如何做好动静分离？

秒杀的场景 中，对于系统的要求其实就三个字：快、准、稳。

### 何为动静数据？

-   “动态数据”和“静态数据”的主要区别：看⻚⾯中输出的数据是否和 URL、浏览 者、时间、地域相关，以及是否含有 Cookie 等私密数据。
-   数据中是否含有和访问者相关的个性化数据。

PS：⻚⾯中“不包含”，指的是“⻚⾯的 HTML 源码中不含有

### 怎样对静态数据做缓存呢？

-   第⼀，你应该把静态数据缓存到离⽤户最近的地⽅。

    缓存到哪⾥呢？常⻅的就三种，⽤户浏览器⾥、CDN 上或者在服 务端的 Cache 中。

-   第⼆，静态化改造就是要直接缓存 HTTP 连接。

    静态化改造是直接缓存 HTTP 连接⽽不是仅仅缓存数据。

-   第三，让谁来缓存静态数据也很重要。

    不同语⾔写的 Cache 软件处理缓存数据的效率也各不相 同。

### 如何做动静分离的改造？

如何把动态⻚⾯改造 成适合缓存的静态⻚⾯呢？

从以下 5 个⽅⾯来分离出动态内容：

-   1，URL 唯⼀化。

    为啥要 URL 唯⼀呢？是要缓存整个 HTTP 连接，那么以什么作为 Key 呢？就以 URL 作为缓存的 Key，例如以 id=xxx 这个格式进⾏区分。 

-   2，分离浏览者相关的因素。

    浏览者相关的因素包括是否已登录，以及登录身份等

-   3，分离时间因素。

    服务端输出的时间也通过动态请求获取。 

-   4，异步化地域因素。

    详情⻚⾯上与地域相关的因素做成异步⽅式获取。（可以使用动态，但异步更合适）

-   5，去掉 Cookie。

    服务端输出的⻚⾯包含的 Cookie 可以通过代码软件来删除。

PS：去掉 Cookie 并不是⽤户端收到的⻚⾯就不含 Cookie 了，⽽是说，在缓存的静态数据中不含有 Cookie。

再，因为这其 中很多动态内容都会被⻚⾯中的其他模块⽤到，如判断该⽤户是否已登录、⽤户 ID 是否匹配 等，所以这个时候我们应该将这些信息 JSON 化（⽤ JSON 格式组织这些数据），以⽅便前端 获取。

动态内容的处理通常有两种⽅案：ESI（Edge Side Includes）⽅案， CSI（Client Side Include）⽅案。

-   1，ESI ⽅案（或者 SSI）：即在 Web 代理服务器上做动态内容请求，并将请求插⼊到静态⻚ ⾯中，当⽤户拿到⻚⾯时已经是⼀个完整的⻚⾯了。

    这种⽅式对服务端性能有些影响，但是 ⽤户体验较好。 

-   2，CSI ⽅案。即单独发起⼀个异步 JavaScript 请求，以向服务端获取动态内容。

    这种⽅式服 务端性能更佳，但是⽤户端⻚⾯可能会延时，体验稍差。

### 动静分离的⼏种架构⽅案 

有 3 种⽅案可选：

-   1，实体机单机部署； 

    HOW？

    这种⽅案是将虚拟机改为实体机，以增⼤ Cache 的容量，并且采⽤了⼀致性 Hash 分组的⽅式 来提升命中率。

    将 Cache 分成若⼲组，是希望能达到命中率和访问热点的平衡。

    WHY？

    Hash 分 组越少，缓存的命中率肯定就会越⾼，但短板是也会使单个商品集中在⼀个分组中，容易导致 Cache 被击穿，所以我们应该适当增加多个相同的分组，来平衡访问热点和命中率的问题。

    有以下⼏个优点：

    -   1，没有⽹络瓶颈，⽽且能使⽤⼤内存； 

    -   2，既能提升命中率，⼜能减少 Gzip 压缩； 

    -   3，减少 Cache 失效压⼒，因为采⽤定时失效⽅式，例如只缓存 3 秒钟，过期即⾃动失效。

    优势很明显，它 会增加单机的内存容量，但是⼀定程度上也造成了 CPU 的浪费。

    ⼀个实体机上部署了 Java 应⽤⼜作为 Cache 来使⽤，这造成了运维上的高复杂 度，所以这是⼀个折中的⽅案。

-   2，统⼀ Cache 层； 

    将单机的 Cache 统⼀分离出来，形成⼀个单独的 Cache 集群。统⼀ Cache 层是个更理想的可推⼴⽅案。

    将 Cache 层单独拿出来统⼀管理可以减少运维成本，同时也⽅便接⼊其他静态化系统。

    有⼀些优点：

    -   1，单独⼀个 Cache 层，可以减少多个应⽤接⼊时使⽤ Cache 的成本。只要 维护⾃⼰的 Java 系统就好，不需要单独维护 Cache，⽽只关⼼如何使⽤即可。

    -   2，统⼀ Cache 的⽅案更易于维护。只需要⼀套解决⽅案就 ⾏，统⼀起来维护升级也⽐较⽅便。 

    -   3，可以共享内存，最⼤化利⽤内存，不同系统之间的内存可以动态切换，从⽽能够有效应对各 种攻击。

    存在问题：

    -   1，Cache 层内部交换⽹络成为瓶颈； 

    -   2，缓存服务器的⽹卡也会是瓶颈；

    -   3，机器少⻛险较⼤，挂掉⼀台就会影响很⼤⼀部分缓存数据。

    要解决：可以再对 Cache 做 Hash 分组，即⼀组 Cache 缓存的内容相同，这样 能够避免热点数据过度集中导致新的瓶颈产⽣。

-   3，上 CDN。

    将 Cache 进⼀步前移到 CDN 上，因为 CDN 离⽤户最近，效果会更好。

    ⼏个问题需要解决：

    -   1，失效问题。需要保证 CDN 可以在秒级时间内，让分布在全国各地的 Cache 同时失效，这对 CDN 的失效系统要求很 ⾼。 

    -   2，命中率问题。如果将数据全部放到全国的 CDN 上，必然导致 Cache 分散。 Cache 分散 ⼜会导致访问请求命中同⼀个 Cache 的可能性降低，那么命中率就成为⼀个问题。 

    -   3，发布更新问题。如果⼀个业务系统每周都有⽇常业务需要发布，那么发布系统必须⾜够简洁 ⾼效，⽽且你还要考虑有问题时快速回滚和排查问题的简便性。

    是否可以选择若⼲个节点来尝试实施呢？

    节点需要满⾜⼏个条件：

    1，靠近访问量⽐较集中的地区； 

    2，离主站相对较远； 

    3，节点到主站间的⽹络⽐较好，⽽且稳定；

    4，节点容量⽐较⼤，不会占⽤其他 CDN 太多的资源。节点不要太多。

    综上，选择 CDN 的⼆级 Cache ⽐较合适，因为⼆级 Cache 数量偏少，容量也更 ⼤，让⽤户的请求先回源的 CDN 的⼆级 Cache 中，如果没命中再回源站获取数据

    使⽤ CDN 的⼆级 Cache 作为缓存，可以达到和当前服务端静态化 Cache 类似的命中率

    CDN 化部署⽅案还有以下⼏个特点：

    1，把整个⻚⾯缓存在⽤户浏览器中；

    2，如果强制刷新整个⻚⾯，也会请求 CDN；

    3，实际有效请求，只是⽤户对“刷新抢宝”按钮的点击。

    这样就把 90% 的静态数据缓存在了⽤户端或者 CDN 上，当真正秒杀时，⽤户只需要点击特殊 的“刷新抢宝”按钮，⽽不需要刷新整个⻚⾯。

    这样⼀来，系统只是向服务端请求很少的有效数 据，⽽不需要重复请求⼤量的静态数据。

### 总结⼀下

存储在浏览器或 CDN 上，有多⼤区别？区别很⼤！

因为在 CDN 上，我们可以做主动失效，⽽在⽤户的浏览器⾥就更不可控，如果⽤户不主动刷新的话，你很难 主动地把消息推送给⽤户的浏览器。

在什么地⽅把静态数据和动态数据合并并渲染出⼀个完整的⻚⾯也很关键！

如果在服务端合并的话，就要 考虑缓存的数据是否进⾏ Gzip 压缩了：如果缓存 Gzip 压缩后的静态数据可以减少缓存的数据 量，但是进⾏⻚⾯合并渲染时就要先解压，然后再压缩完整的⻚⾯数据输出给⽤户；如果缓存未 压缩的静态数据，这样不⽤解压静态数据，但是会增加缓存容量。