## 你需要了解

实际操作，带你认识实现原理：

-   函数调用，现场保护和恢复
-   IP 寄存器的用途
-   相关汇编指令
-   C 语言参数复制和处理返回值
-   Go 语言参数复制和处理返回值
-   匿名函数调用方式
-   作为返回值的匿名函数
-   直接调用匿名函数
-   闭包如何导致环境变量生命周期延长和堆分配
-   闭包怎么调用的
-   闭包与数据竞争
-   什么是递归
-   为什么会引起堆栈溢出
-   什么是尾调用
-   什么是尾递归优化
-   为什么 Go 编译器对尾递归调用不做优化处理
-   延迟调用的用途
-   defer 与 finally 的对比
-   defer 实现和执行机制
-   利用匿名函数重构作用域
-   defer 带来的性能问题



## 第01课：函数执行

### 调用堆栈和堆栈帧

一个进程启动后，由线程来执行所有的代码，线程启动的时候首先分配一段内存，这段内存用来存储。

分配内存有两种方式：

第一，分配所有线程的内存，每个线程都会有一段内存。线程分配的内存称之为栈，就是说所有线程带的内存通常称之为执行栈，栈基本的结构是先进后出。

第二，使用 new 或者 malloc 之类的命令分配的，称之为堆。堆上面有很多内存块，这些内存块按照需要的大小进行分配，分配完之后必须要释放，主动释放或者 GC 释放。

### 总结

函数调用的时候，首先函数是被线程执行的，这个线程要执行函数调用必须要内存分配，内存分为两块，一块称为堆，一块称为栈。

每个线程都会有自己的栈内存，栈内存是个大整块，调用的时候通过 BP 或者 SP 这两个寄存器来维持当前函数需要操作哪块内存，操作完了以后，直接来调整 BP 或者 SP 寄存器的位置就可以把调用函数的所分配的栈桢空间释放掉。

栈上的内存释放了以后那个内存还在，因为整个栈内存是个整体。这就是整个一大块，我们只不过就是调用时候通过两个寄存器来确定当前操作的时候在这一大块中操作哪一个区域。

栈上内存用 BP 和 SP 来操作一整块内存的一个区域，用完之后把 SP 寄存器指回去，那块空间接下来调用其他函数时候进行复用。

整个栈内存是一大块，是一整块，它没有说释放某块内存这样的一个说法。除非就有一种可能，就是把整个栈空间释放掉。

在堆上我们申请了一段内存，不用的时候可以把这块释放掉，因为在一个函数里面可以多次调用堆内存分配，然后可以分块释放，栈上没有内存释放这种说法。所以这就有个好处在栈上只需要调整两个寄存器 BP、SP 的位置就可以来决定这个内存当前是正在用或者说是可以被其他函数调用来覆盖掉。所以有这样一个说法，**我们尽可能把对象分配到栈上**，因为不需要执行释放操作。

现场恢复时候只需要调整寄存器，那块内存就变得可复用状态了。但是在堆上必须要释放，在栈上的效率显然是要高很多。而且栈这种特性就决定了它是有顺序操作的机制，所以它的效率就高很多。在堆上分配时候要么手动释放要么有垃圾回收器来释放。所以我们在栈上分配的时候，一是效率比较高，第二不会给垃圾回收器带来负担。

每个函数调用的时候都会在栈上用两个寄存器划出一个区域来存储参数、返回值、本地变量类似这样的一些内容，这个区域我们称之为叫栈桢。那么多级调用时候所有的栈桢串在一起我们称之为调用堆栈。

究竟有哪些东西分配在栈上呢？

除了堆上的内存块，还有个指针变量，这个指针变量可能是在栈上。指针本身是个标准的变量，它是有内存空间的，因为可以给指针赋值的，能给它赋值肯定是个对象，没有对地址赋值这样一个说法，地址肯定不能赋值的。所以指针和地址不是一回事。指针是一个标准的变量，里面存了地址信息而已。

## 第02课：参数传递

### Go 参数复制、返回值

Go 语言基于 SP 做加法，因为在 Go 语言里不使用 BP 寄存器，它把 BP 寄存器当作普通寄存器来用，不用 BP 寄存器来维持一个栈桢，只用 SP 指向栈顶就可以了，这跟它的内存管理策略有关系。

Go 语言调用一个方法的时候，首先在栈顶的位置按顺序准备好参数同时给返回值存储空间，100和200是参数，300是返回值的空间。所以 Go 语言调用函数的时候是由调用方来准备参数和返回值的空间。

Go 语言执行一个函数的时候，它的栈桢空间实际上分成两大块，上面 sp 至 sp+18 一整块是用来调用其他函数所需要的空间，因为 Go 语言调用函数的时候得为函数准备参数和返回值的空间

### 总结

任何编译器都会有这样一个责任就是尽可能的把对象分配到栈上尽可能使用寄存器，因为使用寄存器会提高它的效率，尽可能分配到栈上可以减少对垃圾回收器对内存分配的压力，这是编译器本身遵守最基本的规则。但是在日常开发中免不了经常在堆上分配内存，这是在代码优化的时候我们自己知道哪些对象分配在堆上哪些对象分配在栈上。

## 第03课：匿名函数

### 匿名函数调用方式

匿名函数调用方式有两种：

第一种，作为返回值的匿名函数；

普通函数和匿名函数的区别在于普通函数直接 call 地址，匿名函数返回的并不是直接返回匿名函数地址，而是一个包装对象，这个包装对象内部持有匿名函数的地址。所以调用匿名函数的时候，先把包装对象里面的地址取出来，然后再去调用。

作为返回值的匿名函数并不是函数地址，而是个包装对象。

第二种，直接调用匿名函数；

如果匿名函数直接调用的时候，它和普通函数调用根本没有任何区别，只有当它作为返回值的时候才有差别。

总结

第一个匿名函数作为普通函数直接调用的时候，它直接是使用 call 来执行的，没有什么区别。第二个当我们把匿名函数当作返回值的时候，这时候就有个包装对象的创建，进行二次调用的，需要做二次寻址。

## 第04课：闭包

### 何为闭包

一个匿名函数引用了它的上下文对象 x，我们把这种状态称之为闭包。

### 闭包通过指针引用环境变量

闭包严格意义上来说，由两个东西组成的，函数加上环境变量，称之为闭包。

闭包有这样一个问题，比如说有一个函数，函数内部有个环境变量 x，当它返回一个匿名函数的时候，这个函数是通过指针访问环境变量 x 的，并不是把环境变量 x 复制过去，用指针引用环境变 x 量实际上会造成这个局部变量 x 在堆上分配，生命周期延长。

### 闭包导致环境变量生命周期延长和堆分配

### 闭包怎么调用的

闭包返回的结构和匿名函数返回的包装对象其实是一回事，区别是匿名函数返回的包装对象在编译期就生成了然后放到 rodata 段里面，闭包也是类似的包装对象，但是是在运行期生成的，因为运行期生成的情况下这时就没有符号名。运行期生成这样一个对象，这个对象包含了匿名函数的地址，也就是匿名函数作为返回值不管有没有闭包，调用过程是一样的。

**闭包返回的包装对象是一个复合对象**，首先是匿名函数的地址，然后是闭包环境变量的地址，只有返回复合结构在调用匿名函数时候才能拿到环境变量地址

没有闭包的情况下，包装对象只有匿名函数地址没有环境变量指针，因为匿名函数地址是固定的，所以这个包装对象不需要每次生成，编译器把它写到 rodata 里面。如果有闭包的话环境变量的地址在堆上分配的，那么这个地址肯定是在运行期动态生成的，那么包装对象就没有办法在编译期确定，所以这个包装对象就不能生成到 rodata 里面。所以如果没有闭包，所有信息都是固定的，完全可以用唯一的一个对象存在 rodata 里，每次返回出来就可以了。

所以包装对象的含义是编译器生成的，是匿名函数，同样的调用机制来实现，区别在于如果有闭包，返回的包装对象就是动态的，如果没有闭包，返回的包装对象就是编译期确定的只读对象，他们的调用规则完全一样。

### 闭包与数据竞争

闭包可能引起数据竞争，闭包是通过指针引用环境变量，比如说一个函数有个 x，同时返回两个匿名函数，这两个匿名函数都引用 x 的情况下，他们都持有 x 的指针，当两个匿名函数都对 x 并发操作时，就会形成数据竞争效应，因为两个匿名函数都用不同线程执行时，同时去访问 x 就会引起数据竞争，理论上我们需要对它加锁处理。

### 总结

闭包实际上是由两个东西组成的，第一个匿名函数，第二个环境变量，合起来才叫闭包，不同的语言对闭包的处理不太一样。

## 第05课：递归调用

### 什么是递归

函数自己调用自己叫做递归。它调用的时候它会分配新的栈桢么？就是说自己调用自己的时候栈帧的状态是什么样子的？

所谓的自己调用自己实质是什么，只不过执行了相同的代码，但是它依然会分配新的栈帧，一直往上面分配，只不过栈帧的内存状态未必是一样的，数据可能会不一样，.text 中使用的代码一样的而已。如果这个递归函数不小心写错了没有中止，那么会一直往上分配，直到整个栈的空间耗光，耗光的时候会引发一种叫堆栈溢出。

### Go 与 C 栈大小差异

每种语言甚至是每种操作系统甚至不同平台栈空间大小未必是一样的，有些可能是 1MB，有些可能是 10MB，Go 语言是 1GB，另外还有些语言对它是有限制的，它不是限制栈内存耗光了，而是调用递归深度如果超出多少就会认为你是溢出了，比如 Python 语言限制1000次。

### 为什么会引起堆栈溢出（Stack OverFlow）

堆栈在溢出多处情况下发生在递归调用，因为递归调用写的算法有问题，可能没有明确的终止，这时候可能会形成溢出。

递归算法的编写其实要非常的小心，那么通常情况下有几种方式，第一种比如 Go 语言栈桢空间足够大，还有一种方式自己去优化递归算法。

### 什么是尾调用

当函数最后一行是一个函数调用，而且不需要处理返回值的时候，我们管这种调用称之为尾调用。

```
void test(){
   x = 1234
   test()
}
```

重复使用一段内存，内存里面就是存的两部分数据，一部分是局部变量，还有一部分是调用其他函数的参数，那么如果是最后一行，局部变量空间显然是不需要了，调用参数参数传递完之后这段空间也可以不要了。所以上下两部分空间都不要的情况下，那么有必要为新的调用分配新的栈桢呢，当然可以重复使用一段栈桢。

尾调用的时候，编译器可能会对它进行优化，第一种方式重复使用同一个栈桢，这种方式可以避免大量分配新的栈桢，第二种方式可以把整个函数调用优化为一个循环，因为函数调用每一次用的栈的状态是一样的，那么用一个循环把函数块演变成代码块，这样也可以在同一个栈桢内使用，一个循环重复利用的是一个栈桢的本地局部变量区域。所以编译器对于尾调用一般情况下都会尝试进行优化，优化完之后用来避免递归调用。前提是自己去写尾调用，并不是所有编译器都能识别这种方式。

```
int test(){
    x = 1234
    test() + 1
}
```

### 为什么 Go 的编译器对尾递归调用不做优化处理

Go 语言传参和处理返回值需要在栈桢上执行分配操作和复制操作，如果复用当前这个栈桢的话，复制操作实际上就失效了。显然栈桢不能被覆盖，因为不使用寄存器保存传参和返回值，而 GCC 直接用寄存器处理了这些，用寄存器的话就以栈桢空间无关了，所以 GCC 对参数的处理和 Go 语言是不一样的。

Go 语言怎么弥补这件事情呢？它默认栈空间非常大有 1GB，尾调用优化的话，第一种重复使用栈桢，第二种使用非常大的 for 循环，函数执行时间非常长。而 Go 语言有抢占机制，默认策略比如一个函数执行超过 20ms 时候，会让这个函数暂停，把当前线程用于执行其他的任务，它是怎么做到这一点的呢？是在函数调用头部插入一些指令来实现一种抢占。这样想的话，如果把普通的函数调用变成很大的 for 循环，头部插入的指令除了第一次执行外，后面就没有机会执行了，这样就没有办法抢占执行任务，但是如果使用 call 调用函数指令的话，这些指令都有机会都调用一次，这样才有机会把当前调用时间统计起来，可以把当前任务的时间片让出去，这也是 Go 不想做优化的理由。

Go 不做优化未必就是说编译器不够好，也可能是由其他原因造成的，比如 Go 语言如果做优化以后抢占调度机制有可能就会失效，那么它会考虑两者之间取个平衡。GCC 考虑的是 CPU 密集型，Go 考虑的是多任务的公平性，出发点不一样，我们考虑每种优化对于不同的语言选择不同的策略。C 语言默认情况下是不考虑并发的，因为并发是自己处理的，那么 GCC 编译器尽可能在指令上做到性能优先，这是 GCC 目标。Go 语言是指令尽可能优化，前提是 runtime 机制优先，runtime 机制优先于算法优化，所以避免把多次函数调用优化成时间非常长的循环。

## 第06课：延迟调用

### 延迟调用的用途（作用域、IDisposable）

IDisposable 在很多语言里面都有，一般的做法是使用 using，确保超出作用域的时候执行某一个方法做清理操作

Go 语言的延迟调用是函数级别的。

### defer 与 finally 的对比（总能执行）

defer 相当于注册一个延迟调用，延迟调用什么时候执行呢？就是在函数退出时候才执行，using 是超出语句块就执行，这个有差别的。

### 正确理解 defer 实现和执行机制，确保合理使用

### 利用匿名函数重构作用域

所以利用匿名函数缩小作用域，因为不用匿名函数这个作用域相当于 example，如果做了匿名函数重构，当前作用域就变成作用域了。

### 性能问题

很多语言都有类似的语法糖，语法糖会让代码变得更简单，但是多数情况下语法糖都是性能杀手，就像 defer 语句在源码上看上去很简单，使用 defer 关键字就能确保语句一定会被执行不管出错不出错，但是看汇编时候这条语句汇编翻译成很多次函数调用而且很复杂，很显然，从指令级别变成函数调用，这里面性能差异就是数量级的。

### 总结

所以说学习一门语言的时候比如说语言提供很好看上去很酷的功能，需要搞清楚是用什么代价换来的，这个功能如果花费了这么高的代价，需要考虑假如没有多大并发压力，浪费点性能让代码变得很简单会优先使用这个语法糖，但是如果压力非常大，在高并发的情况下，那可能就不会使用，因为这个功能在高并发情况下会被无限放大，放大了之后就会成为性能瓶颈，现在的语言都会很喜欢提供各种各样的语法糖，需要知道这些语法糖是用什么换来的，什么时候该用什么时候不该用，选择的前提是搞懂这些是怎么实现的。