# 动态规划 - 理论

[TOC]

“一个模型三个特征”理论讲解

什么是“一个模型”？

它指的是动态规划适合解决的问题的模型。把这个模型定义为“多阶段决策最优解模型”。一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。

什么是“三个特征”？

1，最优子结构

问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。

2，无后效性

有两层含义：第一层含义，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义，某阶段状态一旦确定，就不受之后阶段的决策影响。

无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。

3，重复子问题

不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。

## 实战分析

假设我们有一个n乘以n的矩阵w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。我们将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。我们把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少呢？

![1553745380143](D:\Documents\笔记本\offer学习复习\动态规划\1553745380143.png)

问题是否符合“一个模型”？

从（0，0）走到（n-1，n-1），总共要走2*（n-1）步，也就对应着2*（n-1）个阶段。每个阶段都有向右走或者向下走两种决策，并且每个阶段都会对应一个状态集合。把状态定义为min_dist（i，j），其中i 表示行，j 表示列。min_dist表达式的值表示从（0，0）到达（i，j）的最短路径长度。所以，这个问题是一个多阶段决策最优解问题，符合动态规划的模型。

![1553745477843](D:\Documents\笔记本\offer学习复习\动态规划\1553745477843.png)

是否符合“三个特征”？

画一下递归树，就会发现，递归树中有重复的节点。重复的节点表示，从左上角到节点对应的位置，有多种路线，这也能说明这个问题中存在重复子问题。

如果我们走到（i，j）这个位置，我们只能通过（i-1，j），（i，j-1）这两个位置移动过来，也就是说，我们想要计算（i，j）位置对应的状态，只需要关心（i-1，j），（i，j-1）两个位置对应的状态，并不关心棋子是通过什么样的路线到达这两个位置的。而且，我们仅仅允许往下和往右移动，不允许后退，所以，前面阶段的状态确定之后，不会被后面阶段的决策所改变，所以，这个问题符合“无后效性”这一特征。

刚刚定义状态的时候，我们把从起始位置（0，0）到（i，j）的最小路径，记作min_dist（i，j）。因为我们只能往右或往下移动，所以，我们只有可能从（i，j-1）或者（i-1，j）两个位置到达（i，j）。也就是说，到达（i，j）的最短路径要么经过（i，j-1），要么经过（i-1，j），而且到达（i，j）的最短路径肯定包含到达这两个位置的最短路径之一。换句话说就是，min_dist（i，j）可以通过min_dist（i，j-1）和min_dist（i-1，j）两个状态推导出来。这就说明，这个问题符合“最优子结构”。

```
min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))
```

## 两种动态规划解题思路总结

解决动态规划问题，一般有两种思路。它们分别叫作，状态转移表法和状态转移方程法。

1，状态转移表法

一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决。所以，当我们拿到问题的时候，我们可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。从递归树中，我们很容易可以看出来，是否存在重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是否能用动态规划解决。

到重复子问题之后，接下来，我们有两种处理思路，第一种是直接用回溯加“备忘录”的方法，来避免重复子问题。从执行效率上来讲，这跟动态规划的解决思路没有差别。第二种是使用动态规划的解决方法，状态转移表法。

状态转移表法是如何工作的？

先画出一个状态表。状态表一般都是二维的，所以你可以把它想象成二维数组。其中，每个状态包含三个变量，行、列、数组值。我们根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，我们将这个递推填表的过程，翻译成代码，就是动态规划代码了。

```
private int minDist = Integer.MAX_VALUE; // 全局变量或者成员变量
// 调用方式：minDistBacktracing(0, 0, 0, w, n);
public void minDistBT(int i, int j, int dist, int[][] w, int n) {
  // 到达了 n-1, n-1 这个位置了，这里看着有点奇怪哈，你自己举个例子看下
  if (i == n && j == n) {
    if (dist < minDist) minDist = dist;
    return;
  }
  if (i < n) { // 往下走，更新 i=i+1, j=j
    minDistBT(i + 1, j, dist+w[i][j], w, n);
  }
  if (j < n) { // 往右走，更新 i=i, j=j+1
    minDistBT(i, j+1, dist+w[i][j], w, n);
  }
}
```

